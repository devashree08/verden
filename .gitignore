// /ui/data/ExcelExport/index.js
import ExcelJS from 'exceljs';

/**
 * exportExcel({ sheets, fileName })
 * sheets: Array<{
 *   name: string,
 *   columns: Array<{ header: string, key: string, width?: number }>,
 *   rows: Array<Record<string, any>>,
 *   highlightHeaders?: string[] // headers to color (e.g., ['Status','2025 Attestation','Subcategory Sign-Off?'])
 * }>
 */
export async function exportExcel({ sheets = [], fileName = 'export.xlsx' }) {
  const wb = new ExcelJS.Workbook();
  wb.created = new Date();

  const usedNames = new Set();
  for (const s of sheets) {
    const wsName = uniqueSheetName(s.name || 'Sheet', usedNames);
    usedNames.add(wsName);

    const ws = wb.addWorksheet(wsName, {
      views: [{ state: 'frozen', xSplit: 0, ySplit: 1 }], // sticky header
      properties: { defaultRowHeight: 16 },
    });

    // Columns
    ws.columns = (s.columns || []).map(col => ({
      header: col.header,
      key: col.key,
      width: col.width || idealWidth(col.header),
      style: { font: { size: 11 }, alignment: { vertical: 'middle', wrapText: true } },
    }));

    // Header styles
    const headerRow = ws.getRow(1);
    headerRow.height = 20;
    headerRow.font = { bold: true };
    headerRow.alignment = { vertical: 'middle' };
    headerRow.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFF3F4F6' }, // light gray
    };
    headerRow.border = {
      bottom: { style: 'thin', color: { argb: 'FFCBD5E1' } },
    };

    // Optional colored headers
    const highlightSet = new Set(s.highlightHeaders || []);
    if (highlightSet.size) {
      for (let c = 1; c <= ws.columns.length; c++) {
        const cell = headerRow.getCell(c);
        const label = cell.value?.toString?.() || '';
        if (highlightSet.has(label)) {
          cell.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: pickHeaderColor(label) },
          };
        }
      }
    }

    // Rows
    (s.rows || []).forEach((r) => ws.addRow(r));

    // Auto filter across header row
    if (ws.columnCount > 0) {
      ws.autoFilter = {
        from: { row: 1, column: 1 },
        to:   { row: 1, column: ws.columnCount },
      };
    }

    // Make "Attribute Definition" wrap a bit nicer
    const defColIndex = ws.columns.findIndex(c => c.header === 'Attribute Definition');
    if (defColIndex >= 0) {
      ws.getColumn(defColIndex + 1).alignment = { vertical: 'middle', wrapText: true };
      ws.getColumn(defColIndex + 1).width = Math.max(ws.getColumn(defColIndex + 1).width, 60);
    }
  }

  // Write + trigger download
  const buffer = await wb.xlsx.writeBuffer();
  const blob = new Blob([buffer], {
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = fileName;
  a.click();
  URL.revokeObjectURL(url);
}

/* ---------------- helpers ---------------- */

function uniqueSheetName(name, used) {
  // Excel sheet name limit = 31 chars; disallow: : \ / ? * [ ]
  const cleaned = (name || 'Sheet')
    .replace(/[:\\/?*\[\]]/g, ' ')
    .substring(0, 31)
    .trim() || 'Sheet';

  if (!used.has(cleaned)) return cleaned;

  // append counters if duplicate
  for (let i = 2; i < 1000; i++) {
    const candidate = (cleaned.substring(0, Math.max(0, 31 - (`_${i}`.length))) + `_${i}`).trim();
    if (!used.has(candidate)) return candidate;
  }
  return `${cleaned.substring(0, 27)}_${Date.now()}`.substring(0, 31);
}

function idealWidth(header) {
  const base = Math.min(Math.max(Math.ceil((header || '').length * 1.1), 14), 32);
  return base;
}

function pickHeaderColor(label) {
  // Specific colored headers per your requirement
  if (label === 'Status') return 'FFFDE68A';               // amber 200
  if (label === '2025 Attestation') return 'FFBAE6FD';     // sky 200
  if (label === 'Subcategory Sign-Off?') return 'FFE9D5FF';// violet 200
  return 'FFF3F4F6'; // fallback (same as base header)
}
