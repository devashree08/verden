"""
Keycloak OIDC for MCP (enterprise-grade, minimal config).

- Validates Authorization: Bearer <JWT> using FastMCP's JWTVerifier
  (signature, issuer, audience, exp/nbf via JWKS).
- Requires an email-style identifier and publishes it to context state ("email")
  so tools can pass it to SQL/BQ (caller cannot override via inputs).

Configuration (from env via framework.core.config):
- OIDC_ISSUER_URI
- OIDC_JWKS_URI
- OIDC_ALLOWED_AUDIENCE
"""

from __future__ import annotations
import logging
from typing import Optional

from fastmcp.server.auth.providers.jwt import JWTVerifier
from fastmcp.server.middleware import Middleware, MiddlewareContext

from ..core.config import (
    OIDC_JWKS_URI,
    OIDC_ISSUER_URI,
    OIDC_ALLOWED_AUDIENCE,
)

log = logging.getLogger(__name__)


def build_jwt_verifier() -> JWTVerifier:
    """
    Construct a JWT verifier using only enterprise-provided OIDC metadata.
    No hardcoded issuers/audiences/keys; everything comes from env.
    """
    if not OIDC_JWKS_URI or not OIDC_ISSUER_URI or not OIDC_ALLOWED_AUDIENCE:
        # Fail fast and loud so misconfiguration is obvious in logs
        raise RuntimeError(
            "JWT auth misconfigured: OIDC_JWKS_URI, OIDC_ISSUER_URI, and OIDC_ALLOWED_AUDIENCE are required"
        )

    return JWTVerifier(
        jwks_uri=OIDC_JWKS_URI,
        issuer=OIDC_ISSUER_URI,
        audience=OIDC_ALLOWED_AUDIENCE,
        # (If your FastMCP later exposes leeway/cache args,
        #  we can add them without changing env names.)
    )


class EmailClaimMiddleware(Middleware):
    """
    Enforce presence of an email-style identity and expose it to tools via context.

    Policy:
      - Token already validated by JWTVerifier (sig/iss/aud/exp/nbf).
      - Extract an email-style identifier from claims.
      - If missing, reject with 403 (caller identity cannot be inferred).
      - Save normalized email (lowercased) into context under key "email".
    """

    async def on_request(self, context: MiddlewareContext, call_next):
        token = context.fastmcp_context.get_access_token()
        if token is None:
            # JWTVerifier would normally block first, but keep this guard explicit
            return await context.fastmcp_context.error("Unauthorized: missing access token", status=401)

        claims = token.claims or {}

        # Prefer the standard 'email' claim, but allow common enterprise aliases
        raw_email: Optional[str] = (
            claims.get("email")
            or claims.get("upn")
            or claims.get("preferred_username")
        )

        if not raw_email:
            # Do NOT guess from non-email claims; require a clear identity
            return await context.fastmcp_context.error("Forbidden: email claim missing", status=403)

        # Normalize and publish for tools. Inputs never accept 'email'â€”this is authoritative.
        context.fastmcp_context.set_state("email", raw_email.strip().lower())

        return await call_next()
