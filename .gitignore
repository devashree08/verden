// /ui/data/ExcelExport/index.js
import ExcelJS from 'exceljs';

/**
 * exportExcel({
 *   fileName: string,
 *   sheets: Array<{
 *     name: string,
 *     columns: Array<{ header: string, key: string, width?: number }>,
 *     rows: Array<Record<string, any>>,
 *     freezeHeader?: boolean,           // default: true
 *     editableHeaders?: string[],       // headers to tint
 *     editableHeaderColor?: string,     // ARGB like 'FFFDE68A' (same color for all editable headers)
 *     autoFilter?: boolean,             // default: true
 *   }>
 * })
 */
export async function exportExcel({ fileName = 'export.xlsx', sheets = [] }) {
  const wb = new ExcelJS.Workbook();
  wb.created = new Date();

  const used = new Set();

  for (const s of sheets) {
    const name = uniqueSheetName(s.name || 'Sheet', used);
    used.add(name);

    const ws = wb.addWorksheet(name, {
      views: [{ state: 'frozen', ySplit: (s.freezeHeader ?? true) ? 1 : 0 }],
      properties: { defaultRowHeight: 16 },
    });

    // define columns
    ws.columns = (s.columns || []).map(col => ({
      header: col.header,
      key: col.key,
      width: col.width ?? idealWidth(col.header),
      style: { font: { size: 11 }, alignment: { vertical: 'middle', wrapText: true } },
    }));

    // header styling
    const headerRow = ws.getRow(1);
    headerRow.height = 20;
    headerRow.font = { bold: true };
    headerRow.alignment = { vertical: 'middle' };
    headerRow.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFF3F4F6' }, // base light gray
    };
    headerRow.border = { bottom: { style: 'thin', color: { argb: 'FFCBD5E1' } } };

    // tint "editable" headers (SAME COLOR for all editable columns)
    const editableSet = new Set(s.editableHeaders || []);
    const editableColor = s.editableHeaderColor || 'FFFDE68A'; // amber-200
    if (editableSet.size) {
      for (let c = 1; c <= ws.columnCount; c++) {
        const label = headerRow.getCell(c).value?.toString?.() || '';
        if (editableSet.has(label)) {
          headerRow.getCell(c).fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: editableColor },
          };
        }
      }
    }

    // rows
    (s.rows || []).forEach(r => ws.addRow(r));

    // auto filter
    if (s.autoFilter ?? true) {
      ws.autoFilter = {
        from: { row: 1, column: 1 },
        to:   { row: 1, column: ws.columnCount },
      };
    }
  }

  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], {
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = fileName;
  a.click();
  URL.revokeObjectURL(url);
}

/* ---------------- helpers ---------------- */

function uniqueSheetName(name, used) {
  const clean = (name || 'Sheet').replace(/[:\\/?*\[\]]/g, ' ').substring(0, 31).trim() || 'Sheet';
  if (!used.has(clean)) return clean;
  for (let i = 2; i < 1000; i++) {
    const candidate = (clean.substring(0, Math.max(0, 31 - (`_${i}`.length))) + `_${i}`).trim();
    if (!used.has(candidate)) return candidate;
  }
  return `${clean.substring(0, 27)}_${Date.now()}`.substring(0, 31);
}

function idealWidth(header) {
  const base = Math.ceil((header || '').length * 1.1);
  return Math.min(Math.max(base, 14), 40);
}
