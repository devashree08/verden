"""
Tool: get_all_apps_summary_by_user  -> dbo.SPGetAllAppsSummaryByUser
- Historical monthly snapshots (current month until freeze)
- Optional VAST filter
- Optional report_month ('YYYY-MM' or 'Month YYYY' → 'YYYY-MM-01 00:00:00')
- Pydantic validation & normalization for inputs
"""

from __future__ import annotations
from typing import Any, Dict, List, Optional, Union
from datetime import datetime

from fastmcp import Context
from pydantic import BaseModel, Field, field_validator
from dateutil import parser as dtparse

from framework.core.registry import mcp
from framework.core.config import DB_BACKEND
from framework.schemas.outputs import ROWS_OUTPUT


class _WithPaging(BaseModel):
    limit: int = Field(
        default=1000,
        description="Max rows to return (1–15000).",
        ge=1,
        le=15000,
        examples=[100, 1000, 5000],
    )
    offset: int = Field(
        default=0,
        description="Row offset for pagination (>= 0).",
        ge=0,
        examples=[0, 100, 1000],
    )

    @field_validator("limit")
    @classmethod
    def cap_limit(cls, v: int) -> int:
        return max(1, min(v, 15_000))

    @field_validator("offset")
    @classmethod
    def non_negative_offset(cls, v: int) -> int:
        return max(0, v)


def _normalize_month_literal(v: Any) -> Optional[str]:
    if v is None:
        return None
    s = str(v).strip()
    if not s:
        return None
    try:
        if len(s) == 7 and s[4] == "-":  # YYYY-MM
            year = int(s[0:4]); month = int(s[5:7])
            dt = datetime(year, month, 1)
        else:
            dt = dtparse.parse(s).replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        return dt.strftime("%Y-%m-%d %H:%M:%S")
    except Exception:
        return None


class AllAppsSummaryParams(_WithPaging):
    vast: Optional[Union[str, List[Union[int, str]]]] = Field(
        default=None,
        description="VAST IDs to filter. Accepts CSV string ('101,202') or array (['101','202']). Omit for all allowed VASTs.",
        examples=["101,202", ["101", "202"]],
    )
    report_month: Optional[str] = Field(
        default=None,
        description="Target month. Accepts 'YYYY-MM' or natural language like 'February 2024'. Normalized to 'YYYY-MM-01 00:00:00'.",
        examples=["2024-02", "February 2024"],
    )

    @field_validator("vast", mode="before")
    @classmethod
    def normalize_vast(cls, v: Any) -> Optional[str]:
        if v is None:
            return None
        if isinstance(v, str):
            s = v.strip()
            return s or None
        if isinstance(v, (list, tuple)):
            parts: List[str] = []
            for item in v:
                if item is None:
                    continue
                s = str(item).strip()
                if s:
                    parts.append(s)
            return ",".join(parts) or None
        s = str(v).strip()
        return s or None

    @field_validator("report_month", mode="before")
    @classmethod
    def normalize_month(cls, v: Any) -> Optional[str]:
        return _normalize_month_literal(v)


@mcp.tool(
    name="get_all_apps_summary_by_user",
    description=(
        "Return historical monthly summaries for the caller's accessible VASTs. "
        "Supports an optional month filter (e.g., '2024-02' or 'February 2024')."
    ),
    output_schema=ROWS_OUTPUT,
)
async def get_all_apps_summary_by_user(
    params: AllAppsSummaryParams,
    ctx: Context,
) -> Dict[str, List[Dict[str, Any]]]]:
    email = (ctx.get_state("email") or "").lower()

    if DB_BACKEND == "mssql":
        from framework.adapters.mssql import call_sp_allapps_summary as run_query
        rows = run_query(
            email=email,
            vast=params.vast,
            report_month=params.report_month,
            limit=params.limit,
            offset=params.offset,
        )
    else:
        from framework.adapters.bigquery import query_allapps_summary as run_query
        rows = run_query(
            email=email,
            vast=params.vast,
            report_month=params.report_month,
            limit=params.limit,
            offset=params.offset,
        )

    return {"rows": rows}
