def ai_descriptions_with_gemini(
    model: str,
    tool_name: str,
    cols: List[Tuple[str, str, Optional[str]]],
) -> Dict[str, str]:
    """
    Call 'gemini' CLI to generate one-sentence descriptions.
    Handles the CLI's tendency to wrap JSON in a top-level {"response": "..."} and
    to put the JSON inside a markdown code block.
    """
    import shutil
    if shutil.which("gemini") is None:
        return {}

    # Strongly constrain the output shape and ask for no markdown.
    prompt = {
        "task": "For each column, write one concise, non-marketing, SME-style description. Do not restate the column name.",
        "table": tool_name,
        "temporal_scope": CANONICAL_BY_TOOL[tool_name],
        "columns": [
            {
                "name": name,
                "normalized_type": norm,
                "bq_type": bqt or "",
                "synthetic_examples": _synthetic_examples(norm),
            }
            for (name, norm, bqt) in cols
        ],
        # Hard rule: emit EXACT JSON we can parse reliably.
        "instructions": (
            "Output EXACTLY this JSON shape and nothing else (no markdown, no fences): "
            "{\"columns\": [{\"name\": \"...\", \"description\": \"...\"}, ...]}"
        ),
    }

    try:
        res = subprocess.run(
            ["gemini", "-m", model, "-p", json.dumps(prompt), "--output-format", "json"],
            check=True,
            capture_output=True,
            text=True,
            timeout=120,
        )
        outer = res.stdout.strip()
        data = json.loads(outer)

        # Some CLI builds put the actual content in data["response"] as a string.
        if isinstance(data, dict) and "response" in data and isinstance(data["response"], str):
            inner = data["response"].strip()
            # Strip common markdown fences if present
            if inner.startswith("```"):
                # remove first fence line and trailing fence
                inner = inner.strip("`")
                # after stripping backticks, try to remove a leading 'json\n'
                if inner.lower().startswith("json\n"):
                    inner = inner[5:]
                inner = inner.strip()
            # Try to parse the inner JSON
            try:
                data = json.loads(inner)
            except Exception:
                # Try to extract JSON lines between fences if any weird wrapping remains
                import re
                m = re.search(r"\{.*\}", inner, flags=re.DOTALL)
                if m:
                    data = json.loads(m.group(0))
                else:
                    return {}

        # By here, expect {"columns":[{"name":...,"description":...}]}
        cols_list = data.get("columns", []) if isinstance(data, dict) else []
        out = {}
        for c in cols_list:
            name = c.get("name")
            desc = (c.get("description") or "").strip()
            if name and desc:
                out[name] = desc
        return out
    except Exception:
        return {}

