# framework/auth/oidc.py
"""
Keycloak OIDC for FastMCP:
- Primary: FastMCP's JWTVerifier validates Authorization: Bearer <JWT>.
- Fallback: If no FastMCP token is present (e.g., Cloud Run IAM in front),
  read X-User-JWT and validate it with PyJWT against JWKS/issuer/audience.

On success, publish normalized email into the request context so tools can read:
    email = ctx.state.get("email")
"""

from __future__ import annotations

import logging
from typing import Optional, Dict, Any
import time

import requests
import jwt
from jwt import PyJWKClient, InvalidTokenError

from fastmcp.server.auth.providers.jwt import JWTVerifier
from fastmcp.server.middleware import Middleware, MiddlewareContext
from fastmcp.server.dependencies import get_access_token, get_http_headers

from ..core.config import (
    OIDC_JWKS_URI,
    OIDC_ISSUER_URI,
    OIDC_ALLOWED_AUDIENCE,
)

log = logging.getLogger(__name__)

# ---- Primary auth provider for Authorization: Bearer <JWT> ----
def build_jwt_verifier() -> JWTVerifier:
    if not (OIDC_JWKS_URI and OIDC_ISSUER_URI and OIDC_ALLOWED_AUDIENCE):
        raise RuntimeError(
            "JWT auth misconfigured: OIDC_JWKS_URI, OIDC_ISSUER_URI, OIDC_ALLOWED_AUDIENCE are required"
        )
    return JWTVerifier(
        jwks_uri=OIDC_JWKS_URI,
        issuer=OIDC_ISSUER_URI,
        audience=OIDC_ALLOWED_AUDIENCE,
    )


# ---- Lightweight JWKS cache for the X-User-JWT fallback path ----
class _JWKCache:
    def __init__(self, jwks_uri: str, ttl_sec: int = 300):
        self.jwks_uri = jwks_uri
        self.ttl = ttl_sec
        self._client = PyJWKClient(jwks_uri)
        self._fetched_at = 0.0

    def get_signing_key(self, token: str):
        # PyJWKClient will refetch as needed; we keep a simple timestamp to avoid chatter in logs
        now = time.time()
        if now - self._fetched_at > self.ttl:
            # Touch JWKS to ensure availability; ignore body here
            try:
                requests.get(self.jwks_uri, timeout=5).raise_for_status()
                self._fetched_at = now
            except Exception as e:
                log.warning("JWKS refresh failed (will rely on cached keys if any): %s", e)
        return self._client.get_signing_key_from_jwt(token).key


_jwk_cache = _JWKCache(OIDC_JWKS_URI) if OIDC_JWKS_URI else None


def _verify_x_user_jwt(raw: str) -> Dict[str, Any]:
    """
    Validate a JWT from X-User-JWT using JWKS/issuer/audience.
    Returns decoded claims dict or raises InvalidTokenError.
    """
    if not _jwk_cache:
        raise InvalidTokenError("JWKS not configured")

    key = _jwk_cache.get_signing_key(raw)
    claims = jwt.decode(
        raw,
        key=key,
        algorithms=["RS256", "RS384", "RS512"],
        audience=OIDC_ALLOWED_AUDIENCE,
        issuer=OIDC_ISSUER_URI,
        options={"require": ["exp", "iat"]},
    )
    return claims


class EmailClaimMiddleware(Middleware):
    """
    Publish a normalized email into the request context for tool access.

    Order of operations:
      1) Use FastMCP's verified Bearer token if present.
      2) If absent, try header X-User-JWT (proxy-provided user JWT).
      3) If neither yields an email, reject.

    Tools read it via: ctx.state.get("email")
    """

    async def on_request(self, context: MiddlewareContext, call_next):
        # 1) Prefer FastMCP's validated access token (Authorization: Bearer ...)
        token = get_access_token()
        email: Optional[str] = None

        if token is not None:
            claims = token.claims or {}
            email = (
                (claims.get("email") or claims.get("upn") or claims.get("preferred_username"))
                or None
            )
            if email:
                email = email.strip().lower()

        # 2) Fallback: X-User-JWT header (when Authorization isn't forwarded)
        if email is None:
            headers = get_http_headers() or {}
            raw = headers.get("x-user-jwt") or headers.get("X-User-JWT")
            if raw:
                try:
                    claims = _verify_x_user_jwt(raw)
                    email = (
                        (claims.get("email") or claims.get("upn") or claims.get("preferred_username"))
                        or None
                    )
                    if email:
                        email = email.strip().lower()
                except InvalidTokenError as e:
                    return await context.fastmcp_context.error(f"Unauthorized: invalid X-User-JWT ({e})", status=401)

        if not email:
            return await context.fastmcp_context.error("Unauthorized: missing user identity", status=401)

        # Expose to tools
        context.fastmcp_context.set_state("email", email)

        # Continue the pipeline
        return await call_next(context)
