// /features/attributeMapping/utils/buildSheetsForAttributeMapping.js

export function buildSheetsForAttributeMapping({ headers = [], rows = [], finalOnly = false }) {
  // org list from headers so we create sheets even when an org has zero rows
  const orgs = dedupeBy(headers.map(h => ({ orgID: h.orgID, orgName: h.orgName })), x => x.orgID);

  // sign-off per (org, subcat)
  const signoff = new Map();
  headers.forEach(h => {
    const key = `${h.orgID}|${h.csF2SubcategoryID}`;
    const cAt = h.completedAt ? new Date(h.completedAt) : null;
    const rAt = h.reopenedAt  ? new Date(h.reopenedAt)  : null;
    const isDone = !!(cAt && (!rAt || cAt >= rAt));
    signoff.set(key, isDone);
  });

  const columns = [
    { header: 'CSF 2.0 Function',      key: 'function',    width: 28 },
    { header: 'CSF 2.0 Category',      key: 'category',    width: 28 },
    { header: 'CSF 2.0 Subcategory',   key: 'subcategory', width: 34 },
    { header: 'ML',                    key: 'ml',          width: 6  },
    { header: 'Attribute #',           key: 'attrNum',     width: 12 },
    { header: 'Attribute Definition',  key: 'attrDef',     width: 80 },
    { header: 'Status',                key: 'status',      width: 14 },
    { header: '2025 Attestation',      key: 'attest2025',  width: 18 },
    { header: '2024 Assessor Score',   key: 'assess2024',  width: 20 },
    { header: 'Subcategory Sign-Off?', key: 'signoff',     width: 22 },
  ];
  const editableHeaders = ['Status', '2025 Attestation', 'Subcategory Sign-Off?'];

  const sheets = orgs.map(({ orgID, orgName }) => {
    const rOrg = rows.filter(r => String(r.orgID) === String(orgID));

    const inScope = finalOnly
      ? rOrg.filter(r => {
          const isCustom = !!(r.isCustom || r.customAttributeDefinition);
          if (isCustom) return true;
          return (r.selectionStatus || '') !== 'Remove';
        })
      : rOrg;

    const excelRows = inScope.map(r => {
      const isCustom = !!(r.isCustom || r.customAttributeDefinition);
      const key = `${r.orgID}|${r.csF2SubcategoryID}`;
      return {
        function:    r.functionName || '',
        category:    r.categoryName || '',
        subcategory: r.csF2SubcategoryName || '',
        ml:          r.maturityLevel ?? '',
        attrNum:     isCustom ? (r.customAttributeNum ?? '') : (r.attributeNum ?? ''),
        attrDef:     r.customAttributeDefinition || r.attributeDefinition || '',
        status:      isCustom ? 'Add' : (r.selectionStatus || ''),
        attest2025:  isCustom ? (r.customAttributeAttestation || '') : (r.selectionAttestation || ''),
        assess2024:  r.assessScore2024 || '',
        signoff:     signoff.get(key) ? 'Yes' : 'No',
      };
    });

    return {
      name: orgName || `Org ${orgID}`,
      columns,
      rows: excelRows,                   // can be empty -> still create sheet with headers
      freezeHeader: true,
      editableHeaders,
      editableHeaderColor: 'FFFDE68A',   // SAME color for all editable columns
    };
  });

  // fallbacks so file always opens
  if (!sheets.length) {
    sheets.push({
      name: 'Export',
      columns,
      rows: [],
      freezeHeader: true,
      editableHeaders,
      editableHeaderColor: 'FFFDE68A',
    });
  }

  return sheets;
}

/* helpers */
function dedupeBy(arr, keyFn) {
  const seen = new Set();
  return arr.filter(x => {
    const k = keyFn(x);
    if (seen.has(k)) return false;
    seen.add(k);
    return true;
  });
}
