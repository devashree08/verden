[Clients] -> [API Gateway] -> [FastAPI routes] -> [Validator] -> [Proc Executor] -> (SQL Procs)
                                 |                                   ^
[Swagger /docs] ------------------+                                   |
[Agent MCP client] -> [MCP server tools] -> [Validator] --------------+
                                   |
                           [Logs / Correlation IDs / Metrics]



# tools_cli.py
# List your MCP tools (like listTools) and call one (like callTool).
# Uses orjson for output so datetime/date serialize cleanly.

import os
import sys
import argparse
import json
from typing import Any, Dict, List

import orjson
from dotenv import load_dotenv

from db import ODBCConnectionPool, POOL_SIZE, exec_proc
from contract import (
    load_registry,
    build_param_contract,
    required_overrides_from_specs,
    validate_params,
)

load_dotenv()

# -------- JSON output (orjson) --------

def _orjson_default(obj: Any) -> Any:
    """
    Optional: if your procs ever return Decimal or raw bytes.
    orjson already handles datetime/date/uuid.
    """
    from decimal import Decimal
    if isinstance(obj, Decimal):
        return str(obj)
    if isinstance(obj, (bytes, bytearray, memoryview)):
        # represent raw bytes safely; adjust if you prefer base64
        return obj.decode("utf-8", errors="replace")
    raise TypeError

def _print_json(obj: Any) -> None:
    sys.stdout.write(orjson.dumps(obj, default=_orjson_default, option=orjson.OPT_INDENT_2).decode("utf-8") + "\n")

def _save_json(path: str, obj: Any) -> None:
    with open(path, "wb") as f:
        f.write(orjson.dumps(obj, default=_orjson_default, option=orjson.OPT_INDENT_2))

# -------- Tool catalog --------

def build_tool_catalog(registry: Dict[str, Any], pool: ODBCConnectionPool) -> List[Dict[str, Any]]:
    catalog: List[Dict[str, Any]] = []
    for ep in registry.get("endpoints", []):
        method = ep["method"].upper()
        specs = build_param_contract(pool, ep["schema"], ep["proc"], method, ep.get("params"))

        props: Dict[str, Any] = {}
        required: List[str] = []
        for s in specs:
            sch: Dict[str, Any] = {"type": s["type"]}
            if "format" in s:
                sch["format"] = s["format"]
            for k in ("maxLength", "minLength", "pattern", "enum", "description"):
                if k in s:
                    sch[k] = s[k]
            props[s["name"]] = sch
            if s.get("required", False):
                required.append(s["name"])

        tool_name = ep.get("toolName") or ep.get("proc") or ep["path"].strip("/").replace("/", "_")
        catalog.append({
            "name": tool_name,
            "description": ep.get("summary") or f"Execute {ep['schema']}.{ep['proc']}",
            "input_schema": {
                "type": "object",
                "additionalProperties": False,
                "properties": props,
                **({"required": required} if required else {})
            }
        })
    return catalog

# -------- Selection & args --------

def select_endpoint(registry: Dict[str, Any], selector: str) -> Dict[str, Any]:
    for e in registry.get("endpoints", []):
        if selector in (e.get("toolName"), e.get("proc"), e.get("path"), e.get("modelName")):
            return e
    raise SystemExit(f"No endpoint matches selector: {selector}")

def parse_args_kv(pairs: List[str]) -> Dict[str, Any]:
    out: Dict[str, Any] = {}
    for p in pairs or []:
        if "=" not in p:
            raise SystemExit(f"Bad --arg '{p}'. Use Name=Value.")
        k, v = p.split("=", 1)
        out[k.strip()] = v.strip()
    return out

# -------- CLI --------

def main() -> None:
    ap = argparse.ArgumentParser(description="MCP tools CLI (catalog + call). Uses orjson for output.")
    ap.add_argument("--catalog", action="store_true", help="Print the tool catalog JSON and exit (like listTools).")
    ap.add_argument("--endpoint", help="Select by toolName OR proc OR path OR modelName.")
    ap.add_argument("--args-json", help="Arguments as JSON string.")
    ap.add_argument("--arg", action="append", help="Add Name=Value (repeatable).")
    ap.add_argument("--limit", type=int, default=5, help="Preview at most N rows (default 5).")
    ap.add_argument("--save", help="Save full result JSON to this path.")
    args = ap.parse_args()

    registry_path = os.getenv("REGISTRY_PATH", "./procs.registry.json")
    registry = load_registry(registry_path)
    pool = ODBCConnectionPool(size=int(os.getenv("POOL_SIZE", str(POOL_SIZE))))

    if args.catalog or not args.endpoint:
        _print_json(build_tool_catalog(registry, pool))
        if not args.endpoint:
            return

    ep = select_endpoint(registry, args.endpoint)
    method = ep["method"].upper()

    # Build argument object
    arg_obj: Dict[str, Any] = {}
    if args.args_json:
        try:
            arg_obj.update(json.loads(args.args_json))  # parsing input is fine with stdlib
        except json.JSONDecodeError as ex:
            raise SystemExit(f"--args-json invalid: {ex}")
    if args.arg:
        arg_obj.update(parse_args_kv(args.arg))

    # Validate like MCP would
    specs = build_param_contract(pool, ep["schema"], ep["proc"], method, ep.get("params"))
    source = "query" if method == "GET" else "body"
    errors = validate_params(specs, arg_obj, source)
    if errors:
        _print_json({"fault": {"faultstring": "Bad Request", "detail": [{"errorcode": e} for e in errors]}})
        sys.exit(1)

    # Exec proc (same path as server)
    rows = exec_proc(pool, ep["schema"], ep["proc"], arg_obj,
                     required_overrides=required_overrides_from_specs(specs))

    result = {"rows": rows}
    preview = rows[: max(0, args.limit)]
    _print_json({"rows": preview, "preview_count": len(preview), "total_rows": len(rows)})

    if args.save:
        _save_json(args.save, result)
        print(f"Saved full result to: {args.save}")

if __name__ == "__main__":
    main()

