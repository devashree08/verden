"""
Authentication wiring for Keycloak OIDC using FastMCP's built-in JWT verifier,
plus a small middleware that enforces `email` claim and publishes it to context state.

Why this approach?
- We let FastMCP validate Bearer tokens against JWKS/issuer/audience (battle-tested).
- We add one small policy layer for our app (email required + optional issuer allowlist).
Docs:
- Authentication providers & JWTVerifier: gofastmcp.com/servers/auth/authentication
- Middleware & context state: gofastmcp.com/servers/middleware and /servers/context
"""

from __future__ import annotations
import logging
from typing import Optional

from fastmcp.server.auth.providers.jwt import JWTVerifier
from fastmcp.server.middleware import Middleware, MiddlewareContext

from ..core.config import (
    OIDC_JWKS_URI,
    OIDC_ISSUER_URI,
    OIDC_ALLOWED_AUDIENCE,
    REQUIRE_EMAIL_CLAIM,
    ALLOWED_ISSUERS,
)

log = logging.getLogger(__name__)


def build_jwt_verifier() -> JWTVerifier:
    """
    Configure FastMCP's JWT verifier for Keycloak tokens.
    The provider reads Authorization: Bearer <JWT> from HTTP requests automatically.
    """
    if not (OIDC_JWKS_URI and OIDC_ISSUER_URI and OIDC_ALLOWED_AUDIENCE):
        raise RuntimeError("JWT auth misconfigured: OIDC_JWKS_URI, OIDC_ISSUER_URI, OIDC_ALLOWED_AUDIENCE are required")

    return JWTVerifier(
        jwks_uri=OIDC_JWKS_URI,
        issuer=OIDC_ISSUER_URI,
        audience=OIDC_ALLOWED_AUDIENCE,
    )


class EmailClaimMiddleware(Middleware):
    """
    Enforce presence of `email` claim and expose it to tools via context state.

    Flow:
      - Token already validated by JWTVerifier (sig/iss/aud/exp).
      - Extract claims from context (fastmcp stores them in access token metadata).
      - Optionally enforce issuer allowlist and `email` presence.
      - Save normalized email for tools under key: "email".
    """

    async def on_request(self, context: MiddlewareContext, call_next):
        # FastMCP exposes token info via context.fastmcp_context dependencies.
        # We'll read it from the auth provider (already parsed).
        token = context.fastmcp_context.get_access_token()  # returns None if unauthenticated
        if token is None:
            return await context.fastmcp_context.error("Unauthorized: missing access token", status=401)

        claims = token.claims or {}
        iss: Optional[str] = claims.get("iss")
        email: Optional[str] = claims.get("email") or claims.get("upn") or claims.get("preferred_username")

        # Optional issuer allowlist (defense-in-depth if multiple realms exist)
        if ALLOWED_ISSUERS and iss not in ALLOWED_ISSUERS:
            log.warning("Token issuer not allowed", extra={"extra": {"iss": iss}})
            return await context.fastmcp_context.error("Forbidden: issuer not allowed", status=403)

        # Require an email-style identifier (your stored procs expect @Email NVARCHAR)
        if REQUIRE_EMAIL_CLAIM and not email:
            return await context.fastmcp_context.error("Forbidden: email claim missing", status=403)

        # Normalize and publish to context state for tools
        if email:
            context.fastmcp_context.set_state("email", email.strip().lower())

        return await call_next()

