"""
AuditLogMiddleware: one structured JSON log per tool call.

- Correct FastMCP hook signature: on_call_tool(self, context, call_next)
- Extracts tool name and arguments from context payload safely.
- Never logs tokens or full inputs; keeps PII minimal and approved (email).
"""

from __future__ import annotations
import logging
import time
import uuid
from typing import Any, Dict, Optional

from fastmcp.server.middleware import Middleware, MiddlewareContext
from framework.core.config import DB_BACKEND, SERVICE_NAME

log = logging.getLogger(__name__)


def _safe_get_payload(context: MiddlewareContext) -> Optional[Dict[str, Any]]:
    """
    Try a few attribute names used across FastMCP versions to find the request payload.
    We expect a dict containing at least type/name/arguments for call_tool frames.
    """
    for attr in ("payload", "body", "request", "frame", "data"):
        val = getattr(context, attr, None)
        if isinstance(val, dict):
            return val
    return None


def _extract_tool_and_args(context: MiddlewareContext) -> tuple[Optional[str], Optional[Dict[str, Any]]]:
    """
    Best-effort extraction of tool name and arguments from the context payload.
    Expected call_tool shape (typical):
      {"type":"call_tool","name":"<tool>","arguments":{"params":{...}},"id":"..."}
    """
    payload = _safe_get_payload(context)
    if not isinstance(payload, dict):
        # Some builds stash fields on context itself; try common attributes.
        name = getattr(context, "tool_name", None)
        args = getattr(context, "arguments", None)
        if isinstance(args, dict):
            return name, args
        return name, None

    # Standard MCP request shapes
    name = payload.get("name") or payload.get("tool") if isinstance(payload.get("tool"), str) else payload.get("tool", {}).get("name") if isinstance(payload.get("tool"), dict) else None
    arguments = payload.get("arguments")
    if not isinstance(arguments, dict):
        arguments = None
    return name, arguments


class AuditLogMiddleware(Middleware):
    async def on_call_tool(self, context: MiddlewareContext, call_next):
        start = time.perf_counter()

        # Correlation
        request_id = context.headers.get("x-request-id") or str(uuid.uuid4())
        trace = context.headers.get("x-cloud-trace-context", "")

        # Identity (approved PII)
        email = context.state.get("email", "")

        # Tool metadata
        tool_name, arguments = _extract_tool_and_args(context)

        # Light input summary (do NOT log full args)
        params = arguments.get("params") if isinstance(arguments, dict) else None
        limit = offset = None
        vast = report_month = None
        try:
            if isinstance(params, dict):
                limit = params.get("limit")
                offset = params.get("offset")
                vast = params.get("vast")
                report_month = params.get("report_month")
        except Exception:
            pass

        def _vast_count(v) -> int:
            if v is None:
                return 0
            if isinstance(v, str):
                return len([t for t in (x.strip() for x in v.split(",")) if t])
            if isinstance(v, (list, tuple)):
                return len([t for t in v if t not in ("", None, "")])
            return 0

        try:
            result = await call_next()

            rows = result.get("rows") if isinstance(result, dict) else None
            row_count = len(rows) if isinstance(rows, list) else None
            latency_ms = round((time.perf_counter() - start) * 1000, 2)

            log.info(
                "tool_call_ok",
                extra={"extra_fields": {
                    "event": "tool_call",
                    "status": "ok",
                    "service": SERVICE_NAME,
                    "tool": tool_name or "unknown",
                    "email": email,
                    "db_backend": DB_BACKEND,
                    "limit": limit,
                    "offset": offset,
                    "vast_count": _vast_count(vast),
                    "has_report_month": bool(report_month),
                    "row_count": row_count,
                    "latency_ms": latency_ms,
                    "request_id": request_id,
                    "trace": trace,
                }},
            )
            return result

        except Exception as exc:
            latency_ms = round((time.perf_counter() - start) * 1000, 2)
            log.error(
                "tool_call_error",
                exc_info=True,
                extra={"extra_fields": {
                    "event": "tool_call",
                    "status": "error",
                    "service": SERVICE_NAME,
                    "tool": tool_name or "unknown",
                    "email": email,
                    "db_backend": DB_BACKEND,
                    "limit": limit,
                    "offset": offset,
                    "vast_count": _vast_count(vast),
                    "has_report_month": bool(report_month),
                    "latency_ms": latency_ms,
                    "request_id": request_id,
                    "trace": trace,
                    "error_type": type(exc).__name__,
                }},
            )
            raise
