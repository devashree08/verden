import os
import queue
import logging
from typing import Any, Dict, List, Optional

import pyodbc
from dotenv import load_dotenv

load_dotenv()
logger = logging.getLogger("db")

def build_conn_str() -> str:
    driver   = os.getenv("SQLSERVER_DRIVER", "ODBC Driver 18 for SQL Server")
    server   = os.getenv("SQLSERVER_SERVER")
    database = os.getenv("SQLSERVER_DATABASE")
    encrypt  = os.getenv("SQLSERVER_ENCRYPT", "yes")
    tsc      = os.getenv("SQLSERVER_TRUSTCERT", "no")
    if not (server and database):
        raise RuntimeError("Missing SQL Server env vars; check .env")
    return f"Driver={{{driver}}};Server={server};Database={database};Encrypt={encrypt};TrustServerCertificate={tsc};".format(driver=driver)

CONN_STR = build_conn_str()
UID = os.getenv("SQLSERVER_UID")
PWD = os.getenv("SQLSERVER_PWD")
POOL_SIZE = int(os.getenv("POOL_SIZE", "8"))

class ODBCConnectionPool:
    """Tiny synchronous pyodbc pool suitable for FastAPI workers."""
    def __init__(self, size: int):
        self._q: "queue.Queue[pyodbc.Connection]" = queue.Queue(maxsize=size)
        for _ in range(size):
            cnxn = pyodbc.connect(CONN_STR, user=UID, password=PWD, autocommit=True, timeout=30)
            self._q.put(cnxn)
    def get(self) -> pyodbc.Connection:
        return self._q.get()
    def put(self, cnxn: pyodbc.Connection):
        self._q.put(cnxn)

def get_proc_parameters(pool: ODBCConnectionPool, schema: str, proc: str) -> List[Dict[str, Any]]:
    """
    Return parameter metadata for a stored proc (input + output).
    Fields: ordinal, name, is_output, sql_type, max_length, precision, scale, has_default
    """
    cnxn = pool.get()
    try:
        cur = cnxn.cursor()
        cur.execute("""
            SELECT p.parameter_id AS ordinal,
                   REPLACE(p.name,'@','') AS name,
                   p.is_output,
                   t.name AS sql_type,
                   p.max_length, p.precision, p.scale,
                   p.has_default_value
            FROM sys.parameters p
            JOIN sys.types t ON p.user_type_id = t.user_type_id
            WHERE p.object_id = OBJECT_ID(?)
            ORDER BY p.parameter_id;
        """, (f"[{schema}].[{proc}]",))
        return [{
            "ordinal": r[0],
            "name": r[1],
            "is_output": bool(r[2]),
            "sql_type": r[3].lower(),
            "max_length": r[4],
            "precision": r[5],
            "scale": r[6],
            "has_default": bool(r[7]),
        } for r in cur.fetchall()]
    finally:
        pool.put(cnxn)

def _coerce(sql_type: str, value: Any) -> Any:
    """Best-effort coercion JSON → SQL type; ODBC validates further."""
    if value is None:
        return None
    t = sql_type.lower()
    try:
        if t in ("int", "smallint", "tinyint", "bigint"):
            return int(value)
        if t in ("bit",):
            return str(value).strip().lower() in ("1", "true", "yes")
        if t in ("decimal", "numeric", "money", "smallmoney", "float", "real"):
            return float(value)
        # Let ODBC parse ISO-8601 strings for date/time/uniqueidentifier/etc.
        return str(value)
    except Exception:
        return value  # DB will complain; API wraps

def exec_proc(
    pool: ODBCConnectionPool,
    schema: str,
    proc: str,
    args: Dict[str, Any],
    required_overrides: Optional[Dict[str, bool]] = None,
) -> List[Dict[str, Any]]:
    """
    Execute a stored procedure with named-args dict (input params only).
    'required_overrides' lets API layer force required/optional per param:
      True  => required
      False => optional
      None/absent => use DB has_default
    Returns rows from SELECT as list[dict]. Missing required param -> raises KeyError(name).
    """
    cnxn = pool.get()
    try:
        cur = cnxn.cursor()
        meta = get_proc_parameters(pool, schema, proc)
        in_params = [p for p in meta if not p["is_output"]]

        bound = []
        for p in sorted(in_params, key=lambda x: x["ordinal"]):
            name = p["name"]
            # decide required using override first, else DB has_default
            is_required = True
            if required_overrides is not None and name in required_overrides:
                is_required = required_overrides[name]
            else:
                is_required = not p["has_default"]

            if name not in args or args[name] is None:
                if is_required:
                    raise KeyError(name)
                val = None
            else:
                val = _coerce(p["sql_type"], args[name])
            bound.append(val)

        placeholders = ", ".join("?" for _ in bound)
        call = f"{{CALL [{schema}].[{proc}] ({placeholders})}}" if bound else f"{{CALL [{schema}].[{proc}]}}"
        cur.execute(call, tuple(bound))
        cols = [c[0] for c in cur.description] if cur.description else []
        rows = [dict(zip(cols, r)) for r in cur.fetchall()] if cur.description else []
        return rows
    finally:
        pool.put(cnxn)





import os
import json
import logging
from typing import Any, Dict, List, Optional
from contextlib import asynccontextmanager

from dotenv import load_dotenv
from fastapi import FastAPI, APIRouter, Request, Depends, Body, HTTPException
from fastapi.responses import JSONResponse
from fastapi.openapi.utils import get_openapi

from db import ODBCConnectionPool, get_proc_parameters, exec_proc, POOL_SIZE

# ------------------------------------------------------------------------------
# Setup
# ------------------------------------------------------------------------------
load_dotenv()
logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger("api")

API_KEY = os.getenv("API_KEY", "super-secret-key")
REGISTRY_PATH = os.getenv("REGISTRY_PATH", "./procs.registry.json")

def load_registry() -> Dict[str, Any]:
    if not os.path.exists(REGISTRY_PATH):
        raise FileNotFoundError(f"Registry not found: {REGISTRY_PATH}")
    with open(REGISTRY_PATH, "r", encoding="utf-8") as f:
        return json.load(f)

registry = load_registry()

def require_api_key(request: Request):
    if request.headers.get("X-API-Key") != API_KEY:
        raise HTTPException(
            status_code=401,
            detail={"fault": {"faultstring": "Unauthorized", "detail": {"errorcode": "E_UNAUTHORIZED"}}},
        )

def error_response(status_code: int, faultstring: str, codes: str | List[str]) -> JSONResponse:
    detail = [{"errorcode": c} for c in codes] if isinstance(codes, list) else {"errorcode": codes}
    return JSONResponse(status_code=status_code, content={"fault": {"faultstring": faultstring, "detail": detail}})

# ------------------------------------------------------------------------------
# Lifespan
# ------------------------------------------------------------------------------
@asynccontextmanager
async def lifespan(app: FastAPI):
    app.state.pool = ODBCConnectionPool(size=POOL_SIZE)
    register_from_registry(app)
    yield

app = FastAPI(
    title=os.getenv("API_TITLE", "ProcBridge API"),
    version=os.getenv("API_VERSION", "1.0.0"),
    description="Create APIs from selected stored procedures. GET for read-only procs; POST for upserts.",
    lifespan=lifespan,
)

router = APIRouter()

# ------------------------------------------------------------------------------
# Helpers
# ------------------------------------------------------------------------------
def params_required_map(ep_params: List[Dict[str, Any]]) -> Dict[str, bool]:
    """
    Build a {param_name: required_bool} map from registry params list.
    If ep_params is missing or a param isn't listed, we'll fall back to DB defaults later.
    """
    m: Dict[str, bool] = {}
    for p in ep_params or []:
        name = p.get("name")
        if not name:
            continue
        m[name] = bool(p.get("required", False))
    return m

def normalize_param_sources(ep_params: List[Dict[str, Any]], method: str) -> Dict[str, str]:
    """
    Returns {param_name: 'query'|'body'} based on registry (or default by method).
    """
    src: Dict[str, str] = {}
    for p in ep_params or []:
        name = p.get("name")
        if not name:
            continue
        where = p.get("in")
        if where in ("query", "body"):
            src[name] = where
        else:
            src[name] = "query" if method == "GET" else "body"
    return src

def oa_type_from_registry_or_db(reg_type: Optional[str], db_sql_type: Optional[str]) -> Dict[str, Any]:
    """
    Map to OpenAPI schema type. Registry wins; DB type is fallback.
    """
    if reg_type in ("string", "integer", "number", "boolean"):
        return {"type": reg_type}
    if db_sql_type:
        t = db_sql_type.lower()
        if t in ("int","smallint","tinyint","bigint"): return {"type":"integer"}
        if t in ("decimal","numeric","money","smallmoney","float","real"): return {"type":"number"}
        if t == "bit": return {"type":"boolean"}
    return {"type":"string"}

# ------------------------------------------------------------------------------
# Dynamic routes for ONLY the procs you specify
# ------------------------------------------------------------------------------
def register_from_registry(app: FastAPI):
    for ep in registry.get("endpoints", []):
        register_endpoint(app, ep)
    app.include_router(router)

def register_endpoint(app: FastAPI, ep: Dict[str, Any]):
    required = {"schema", "proc", "path", "method"}
    missing = required - set(ep)
    if missing:
        raise RuntimeError(f"Registry entry missing keys: {missing}")

    schema = ep["schema"]
    proc   = ep["proc"]
    path   = ep["path"]
    method = ep["method"].upper()
    summary = ep.get("summary", f"Execute {schema}.{proc}")
    description = ep.get("description", "")
    ep_params = ep.get("params", [])  # ← your explicit params definition
    req_map = params_required_map(ep_params)
    src_map = normalize_param_sources(ep_params, method)

    if method == "GET":
        async def handler(request: Request, _auth=Depends(require_api_key)):
            try:
                pool: ODBCConnectionPool = request.app.state.pool
                meta = get_proc_parameters(pool, schema, proc)
                query = dict(request.query_params)
                args: Dict[str, Any] = {}
                missing: List[str] = []

                # Build arguments from query using registry as the contract
                db_params_by_name = {p["name"]: p for p in meta if not p["is_output"]}
                for p in ep_params:
                    name = p["name"]
                    if src_map.get(name, "query") != "query":
                        continue  # ignore body-only on GET
                    if name in query:
                        args[name] = query[name]
                    elif req_map.get(name, False):  # required per registry
                        missing.append(name)

                # Allow extra DB params not listed in registry only if DB says they have defaults
                for name, p in db_params_by_name.items():
                    if name in args or name in req_map:
                        continue
                    if not p["has_default"]:
                        # not in registry and no default → treat as required and missing
                        missing.append(name)

                if missing:
                    return error_response(400, "Bad Request", [f"E_MISSING_{m.upper()}" for m in missing])

                rows = exec_proc(pool, schema, proc, args, required_overrides=req_map)
                return {"rows": rows}
            except KeyError as k:
                return error_response(400, "Bad Request", f"E_MISSING_{str(k).strip('\"').upper()}")
            except Exception:
                logger.exception("GET exec failed for %s.%s", schema, proc)
                return error_response(500, "Server error", "E_SERVER")

        router.add_api_route(
            path,
            handler,
            methods=["GET"],
            name=f"{schema}.{proc}",
            summary=summary,
            description=description,
            responses={
                400: {"description": "Bad Request"},
                401: {"description": "Unauthorized"},
                500: {"description": "Server Error"}
            },
        )

    elif method == "POST":
        async def handler(payload: Dict[str, Any] = Body(...), request: Request = None, _auth=Depends(require_api_key)):
            try:
                if not isinstance(payload, dict):
                    return error_response(400, "Bad Request", "E_BODY_NOT_OBJECT")
                pool: ODBCConnectionPool = request.app.state.pool
                # Registry drives required/optional
                missing = [p["name"] for p in ep_params if src_map.get(p["name"], "body") == "body" and p.get("required", False) and payload.get(p["name"]) is None]
                if missing:
                    return error_response(400, "Bad Request", [f"E_MISSING_{m.upper()}" for m in missing])

                rows = exec_proc(pool, schema, proc, payload, required_overrides=req_map)
                return {"rows": rows}
            except KeyError as k:
                return error_response(400, "Bad Request", f"E_MISSING_{str(k).strip('\"').upper()}")
            except Exception:
                logger.exception("POST exec failed for %s.%s", schema, proc)
                return error_response(500, "Server error", "E_SERVER")

        router.add_api_route(
            path,
            handler,
            methods=["POST"],
            name=f"{schema}.{proc}",
            summary=summary,
            description=description,
            responses={
                400: {"description": "Bad Request"},
                401: {"description": "Unauthorized"},
                500: {"description": "Server Error"}
            },
        )
    else:
        raise RuntimeError(f"Unsupported method '{method}'. Use GET or POST.")

# ------------------------------------------------------------------------------
# OpenAPI 3.1 + 42C error schema + use **registry** to declare param schemas
# ------------------------------------------------------------------------------
def custom_openapi():
    spec = get_openapi(
        title=app.title, version=app.version, description=app.description, routes=app.routes
    )
    spec["openapi"] = "3.1.0"

    # 42C error schema
    comps = spec.setdefault("components", {}).setdefault("schemas", {})
    comps["ErrorResponse"] = {
        "type": "object",
        "additionalProperties": False,
        "properties": {
            "fault": {
                "type": "object",
                "additionalProperties": False,
                "properties": {
                    "faultstring": {"type": "string"},
                    "detail": {
                        "oneOf": [
                            {"type": "object", "properties": {"errorcode": {"type": "string"}}, "additionalProperties": False},
                            {"type": "array", "maxItems": 10, "items": {
                                "type": "object", "properties": {"errorcode": {"type": "string"}}, "additionalProperties": False
                            }}
                        ]
                    }
                }
            }
        }
    }
    # API key security
    spec["components"].setdefault("securitySchemes", {})
    spec["components"]["securitySchemes"]["apiKeyAuth"] = {"type":"apiKey","in":"header","name":"X-API-Key"}
    spec["security"] = [{"apiKeyAuth": []}]

    # Enrich GET endpoints using registry param definitions
    paths = spec.get("paths", {})
    pool: Optional[ODBCConnectionPool] = getattr(app.state, "pool", None)
    for ep in registry.get("endpoints", []):
        if ep.get("method","GET").upper() != "GET":
            continue
        s, p, path = ep["schema"], ep["proc"], ep["path"]
        reg_params = ep.get("params", [])
        db_meta = None
        if pool is not None:
            try:
                db_meta = {m["name"]: m for m in get_proc_parameters(pool, s, p)}
            except Exception:
                db_meta = {}

        # Build parameter list for OpenAPI from registry (fallback to DB types)
        params = []
        for prm in reg_params:
            if prm.get("in", "query") != "query":
                continue
            name = prm["name"]
            reg_type = prm.get("type")
            db_type = db_meta.get(name, {}).get("sql_type") if db_meta else None
            params.append({
                "name": name,
                "in": "query",
                "required": bool(prm.get("required", False)),
                "schema": oa_type_from_registry_or_db(reg_type, db_type),
                "description": prm.get("description", db_type.upper() if db_type else "")
            })

        # Attach or replace in spec
        try:
            op = paths[path]["get"]
            op["parameters"] = params
            # 42C error schemas
            for sc in ("400","401","500"):
                op.setdefault("responses", {}).setdefault(
                    sc,
                    {"description":"", "content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorResponse"}}}},
                )
        except KeyError:
            pass

    return spec

app.openapi = custom_openapi

# ------------------------------------------------------------------------------
# Local run helper (Swagger at /docs)
# ------------------------------------------------------------------------------
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=False)




