"""
BigQuery adapter (fallback path).

- Uses application default credentials (Cloud Run service account).
- Enforces access by deriving caller EID from workers table, then joining to vast map.
- Returns rows as List[Dict[str, Any]].
- Applies LIMIT/OFFSET in SQL to keep transfers small.
"""

from __future__ import annotations
from typing import Any, Dict, List, Optional, Union
from datetime import datetime
from dateutil import parser as dtparse
import logging

from google.cloud import bigquery

from ..core.config import (
    BQ_PROJECT_ID,
    BQ_DATASET,
    BQ_TABLE_ALLAPPS_VALUE,
    BQ_TABLE_ALLAPPS_SUMMARY,
    BQ_TABLE_VAST_GENERAL,
)

log = logging.getLogger(__name__)


# Reference tables (same dataset). If your org uses different names, update here once.
_REF_WORKERS = "ref_aaas_workers_outbound"
_REF_EID_VAST = "ref_eid_vast_map"


def _client() -> bigquery.Client:
    # If BQ_PROJECT_ID is empty, bigquery.Client() will use default project from credentials.
    return bigquery.Client(project=BQ_PROJECT_ID or None)


def _normalize_vast_csv(vast: Optional[Union[str, List[Union[int, str]]]]) -> Optional[str]:
    if vast is None:
        return None
    if isinstance(vast, str):
        s = vast.strip()
        return s if s else None
    tokens = []
    for v in vast:
        if v is None:
            continue
        tokens.append(str(v).strip())
    csv = ",".join(t for t in tokens if t)
    return csv or None


def _normalize_report_month_literal(report_month: Optional[Union[str, datetime]]) -> Optional[str]:
    if report_month is None:
        return None
    if isinstance(report_month, datetime):
        return report_month.replace(day=1, hour=0, minute=0, second=0, microsecond=0).strftime("%Y-%m-%d %H:%M:%S")
    s = str(report_month).strip()
    if not s:
        return None
    try:
        if len(s) == 7 and s[4] == "-":
            year = int(s[0:4])
            month = int(s[5:7])
            dt = datetime(year, month, 1)
        else:
            dt = dtparse.parse(s)
            dt = dt.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        return dt.strftime("%Y-%m-%d %H:%M:%S")
    except Exception:
        return None


def _run_query(sql: str, params: Dict[str, Any], timeout: int = 90) -> List[Dict[str, Any]]:
    client = _client()
    job_config = bigquery.QueryJobConfig(
        query_parameters=[
            bigquery.ScalarQueryParameter(k, _bq_type(v), v) for k, v in params.items()
        ]
    )
    query_job = client.query(sql, job_config=job_config)
    result = query_job.result(timeout=timeout)  # type: ignore[arg-type]
    rows: List[Dict[str, Any]] = []
    for row in result:
        rows.append(dict(row.items()))
    return rows


def _bq_type(v: Any) -> str:
    if isinstance(v, bool):
        return "BOOL"
    if isinstance(v, int):
        return "INT64"
    # ReportMonth literal is a string literal in DB format
    return "STRING"


def _email_to_eid_cte() -> str:
    ds = BQ_DATASET
    return f"""
WITH email_to_eid AS (
  SELECT CAST(MIN(w.identityeid) AS STRING) AS eid
  FROM `{BQ_PROJECT_ID}.{ds}.{_REF_WORKERS}` AS w
  WHERE LOWER(TRIM(w.emailaddressinternal)) = LOWER(TRIM(@email))
),
allowed_vasts AS (
  SELECT DISTINCT ev.vast_id
  FROM `{BQ_PROJECT_ID}.{ds}.{_REF_EID_VAST}` AS ev
  JOIN email_to_eid e ON ev.eid = e.eid
)
"""


def _vast_filter_sql(column_name: str) -> str:
    # If @vast_csv is provided, restrict to both allowed_vasts and provided set
    return f"""
AND (
  @vast_csv IS NULL
  OR {column_name} IN UNNEST(
      ARRAY(
        SELECT CAST(TRIM(x) AS INT64)
        FROM UNNEST(SPLIT(@vast_csv, ',')) AS x
        WHERE TRIM(x) != ''
      )
    )
)
AND (
  {column_name} IN (SELECT vast_id FROM allowed_vasts)
)
"""


def query_allapps_value(
    *,
    email: str,
    vast: Optional[Union[str, List[Union[int, str]]]] = None,
    limit: int = 1000,
    offset: int = 0,
) -> List[Dict[str, Any]]:
    """
    Fallback for SPGetAllAppsValueByUser (current month snapshot).
    The table already contains only current-month rows (per your export).
    """
    vast_csv = _normalize_vast_csv(vast)
    sql = f"""
{_email_to_eid_cte()}
SELECT *
FROM `{BQ_PROJECT_ID}.{BQ_DATASET}.{BQ_TABLE_ALLAPPS_VALUE}`
WHERE TRUE
{_vast_filter_sql("VastID")}
ORDER BY VastID
LIMIT @limit OFFSET @offset
"""
    params = {"email": email, "vast_csv": vast_csv, "limit": int(limit), "offset": int(offset)}
    return _run_query(sql, params)


def query_allapps_summary(
    *,
    email: str,
    vast: Optional[Union[str, List[Union[int, str]]]] = None,
    report_month: Optional[Union[str, datetime]] = None,
    limit: int = 1000,
    offset: int = 0,
) -> List[Dict[str, Any]]:
    """
    Fallback for SPGetAllAppsSummaryByUser (historical monthly snapshots)
    If @report_month is provided, filter to that literal 'YYYY-MM-01 00:00:00'.
    """
    vast_csv = _normalize_vast_csv(vast)
    report_literal = _normalize_report_month_literal(report_month)
    filter_rm = "AND ReportMonth = @report_month" if report_literal else ""

    sql = f"""
{_email_to_eid_cte()}
SELECT *
FROM `{BQ_PROJECT_ID}.{BQ_DATASET}.{BQ_TABLE_ALLAPPS_SUMMARY}`
WHERE TRUE
{_vast_filter_sql("VastID")}
{filter_rm}
ORDER BY ReportMonth DESC, VastID
LIMIT @limit OFFSET @offset
"""
    params = {
        "email": email,
        "vast_csv": vast_csv,
        "report_month": report_literal,
        "limit": int(limit),
        "offset": int(offset),
    }
    return _run_query(sql, params)


def query_vast_general(
    *,
    email: str,
    vast: Optional[Union[str, List[Union[int, str]]]] = None,
    limit: int = 1000,
    offset: int = 0,
) -> List[Dict[str, Any]]:
    """
    Fallback for SPGetVastGeneralByUser (compliance/general; includes decommissioned).
    """
    vast_csv = _normalize_vast_csv(vast)
    sql = f"""
{_email_to_eid_cte()}
SELECT *
FROM `{BQ_PROJECT_ID}.{BQ_DATASET}.{BQ_TABLE_VAST_GENERAL}`
WHERE TRUE
{_vast_filter_sql("VastID")}
ORDER BY VastID
LIMIT @limit OFFSET @offset
"""
    params = {"email": email, "vast_csv": vast_csv, "limit": int(limit), "offset": int(offset)}
    return _run_query(sql, params)
