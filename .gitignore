#!/usr/bin/env python3
"""
Hydrate descriptions in server/resources/fields/allapps_score.yaml using dbo.Risk_Element.

- Matches Risk_Element.elementName to YAML column names using a canonical key:
  lowercased, non-alphanumeric stripped (drops spaces, '/', '_', etc.)
  e.g., "SPI/PII Application" -> "spipiiapplication", "OCI Servers" -> "ociservers"

- Replaces column 'description' with cleaned 'scoreMessage' where matched,
  and sets description_auto: true.

Usage:
    uv run python scripts/hydrate_score_descriptions.py --dry-run --preview 20
    uv run python scripts/hydrate_score_descriptions.py --write
"""

from __future__ import annotations

import argparse
import contextlib
import html
import logging
import re
from pathlib import Path
from typing import Any, Dict, List, Tuple

import pyodbc
from ruamel.yaml import YAML

from framework.core.config import (
    SQLSERVER_HOST,
    SQLSERVER_PORT,
    SQLSERVER_DATABASE,
    SQLSERVER_USERNAME,
    SQLSERVER_PASSWORD,
    ALLOW_INSECURE_SQL_ENCRYPTION,
)

yaml = YAML()
yaml.default_flow_style = False
yaml.indent(mapping=2, sequence=2, offset=2)

log = logging.getLogger("hydrate_score_descriptions")

# ----------------------- Connection helpers -----------------------

_CONNECT_TIMEOUT = 10


def _conn_str() -> str:
    enc = "no" if ALLOW_INSECURE_SQL_ENCRYPTION else "yes"
    trust = "yes" if ALLOW_INSECURE_SQL_ENCRYPTION else "no"
    return (
        f"Driver={{ODBC Driver 18 for SQL Server}};"
        f"Server=tcp:{SQLSERVER_HOST},{SQLSERVER_PORT};"
        f"Database={SQLSERVER_DATABASE};"
        f"Uid={SQLSERVER_USERNAME};"
        f"Pwd={SQLSERVER_PASSWORD};"
        f"Encrypt={enc};"
        f"TrustServerCertificate={trust};"
        f"Connection Timeout={_CONNECT_TIMEOUT};"
    )


@contextlib.contextmanager
def _connect():
    cn = pyodbc.connect(_conn_str())
    try:
        yield cn
    finally:
        with contextlib.suppress(Exception):
            cn.close()


# ----------------------- Helpers -----------------------

_CANON = re.compile(r"[^a-z0-9]+")


def _canon(s: str) -> str:
    return _CANON.sub("", s.lower())


def _strip_html(s: str) -> str:
    # remove basic <p>..</p> and other tags, unescape entities
    s = re.sub(r"</?p[^>]*>", " ", s, flags=re.IGNORECASE)
    s = re.sub(r"<[^>]+>", " ", s)
    s = html.unescape(s)
    return " ".join(s.split()).strip()


def _load_yaml(path: Path) -> Dict[str, Any]:
    if not path.exists():
        raise FileNotFoundError(f"YAML not found: {path}")
    with path.open("r", encoding="utf-8") as f:
        return yaml.load(f) or {}


def _save_yaml(path: Path, data: Dict[str, Any]) -> None:
    with path.open("w", encoding="utf-8") as f:
        yaml.dump(data, f)


# ----------------------- Main -----------------------

def _fetch_risk_elements(cn) -> List[Tuple[str, str]]:
    cur = cn.cursor()
    cur.execute("SELECT elementName, scoreMessage FROM dbo.Risk_Element")
    out: List[Tuple[str, str]] = []
    for name, msg in cur.fetchall():
        if not name or not msg:
            continue
        out.append((str(name), str(msg)))
    return out


def main():
    ap = argparse.ArgumentParser(description="Hydrate score YAML descriptions from dbo.Risk_Element.")
    ap.add_argument("--write", action="store_true", help="Persist changes; otherwise dry-run.")
    ap.add_argument("--preview", type=int, default=20, help="Show first N updates in dry-run.")
    args = ap.parse_args()

    logging.basicConfig(level=logging.INFO, format="%(levelname)s %(message)s")

    # Locate score yaml
    yaml_path = Path(__file__).resolve().parents[1] / "server" / "resources" / "fields" / "allapps_score.yaml"
    data = _load_yaml(yaml_path)
    cols = data.get("columns") or []
    if not cols:
        log.error("No 'columns' found in %s. Run gen_field_dicts.py first.", yaml_path)
        return

    # Canonical map of YAML columns
    yaml_by_key: Dict[str, Dict[str, Any]] = {}
    for col in cols:
        name = str(col.get("name", "")).strip()
        if not name:
            continue
        yaml_by_key[_canon(name)] = col

    # Fetch risk elements
    updates: List[Tuple[str, str]] = []
    with _connect() as cn:
        for elem_name, score_msg in _fetch_risk_elements(cn):
            key = _canon(elem_name)
            if not key:
                continue
            col = yaml_by_key.get(key)
            if not col:
                continue
            cleaned = _strip_html(score_msg)
            if not cleaned:
                continue
            old_desc = col.get("description", "")
            if old_desc != cleaned:
                col["description"] = cleaned
                col["description_auto"] = True
                updates.append((col.get("name", elem_name), cleaned))

    if not updates:
        print("[dry-run] No matching columns to update.")
        return

    if args.write:
        _save_yaml(yaml_path, data)
        print(f"[write]   Updated {len(updates)} column descriptions in {yaml_path}")
    else:
        print(f"[dry-run] Would update {len(updates)} columns in {yaml_path}")
        for i, (name, desc) in enumerate(updates[: max(1, args.preview)]):
            print(f"  - {name}: {desc[:120]}{'â€¦' if len(desc) > 120 else ''}")


if __name__ == "__main__":
    main()

