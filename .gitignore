// src/features/attributeMapping/utils/attributeWorkbook.js

export function buildSheetsForAttributeMapping({ headers = [], rows = [], finalOnly = false, artifacts = new Map() }) {
  // org list from headers so we create sheets even when an org has zero rows
  const orgs = dedupeBy(headers.map(h => ({ orgID: h.orgID, orgName: h.orgName })), x => x.orgID);

  // sign-off per (org, subcat)
  const signoff = new Map();
  headers.forEach(h => {
    const key = `${h.orgID}|${h.csF2SubcategoryID}`;
    const cAt = h.completedAt ? new Date(h.completedAt) : null;
    const rAt = h.reopenedAt  ? new Date(h.reopenedAt)  : null;
    const isDone = !!(cAt && (!rAt || cAt >= rAt));
    signoff.set(key, isDone);
  });

  // Composite key must match exporter
  const makeKey = (r) => {
    const org = String(r.orgID ?? '0');
    const sub = String(r.csF2SubcategoryID ?? '0');
    const ml  = String(r.maturityLevel ?? '0');
    const isCustom = !!(r.isCustom || r.customAttributeDefinition || r.customAttributeNum != null);
    if (isCustom) {
      return `${org}|${sub}|${ml}|C|0|${String(r.customAttributeNum ?? '0')}`;
    }
    const csf1 = String(r.csF1SubcategoryID ?? '0');
    return `${org}|${sub}|${ml}|B|${csf1}|${String(r.attributeNum ?? '0')}`;
  };

  const columns = [
    // (Optional) if you already added an "Org" column earlier, keep position consistent
    { header: 'CSF 2.0 Function',      key: 'function',    width: 28 },
    { header: 'CSF 2.0 Category',      key: 'category',    width: 28 },
    { header: 'CSF 2.0 Subcategory',   key: 'subcategory', width: 34 },
    { header: 'ML',                    key: 'ml',          width: 6  },
    { header: 'Attribute #',           key: 'attrNum',     width: 12 },
    { header: 'Attribute Definition',  key: 'attrDef',     width: 80 },
    { header: 'Artifacts',             key: 'artifacts',   width: 60 },   // <-- NEW
    { header: 'Status',                key: 'status',      width: 14 },
    { header: '2025 Attestation',      key: 'attest2025',  width: 18 },
    { header: '2024 Assessor Score',   key: 'assess2024',  width: 20 },
    { header: 'Subcategory Sign-Off?', key: 'signoff',     width: 22 },
  ];

  const editableHeaders = ['Status', '2025 Attestation', 'Subcategory Sign-Off?'];

  const sheets = orgs.map(({ orgID, orgName }) => {
    const rOrg = rows.filter(r => String(r.orgID) === String(orgID));

    const inScope = finalOnly
      ? rOrg.filter(r => {
          const isCustom = !!(r.isCustom || r.customAttributeDefinition);
          if (isCustom) return true;
          return (r.selectionStatus || '') !== 'Remove';
        })
      : rOrg;

    const excelRows = inScope.map(r => {
      const isCustom = !!(r.isCustom || r.customAttributeDefinition);
      const key = `${r.orgID}|${r.csF2SubcategoryID}`;
      const artText = artifacts.get(makeKey(r)) || ''; // newline-delimited

      return {
        function:    r.functionName || '',
        category:    r.categoryName || '',
        subcategory: r.csF2SubcategoryName || '',
        ml:          r.maturityLevel ?? '',
        attrNum:     isCustom ? (r.customAttributeNum ?? '') : (r.attributeNum ?? ''),
        attrDef:     r.customAttributeDefinition || r.attributeDefinition || '',
        artifacts:   artText, // <-- NEW
        status:      isCustom ? 'Add' : (r.selectionStatus || ''),
        attest2025:  isCustom ? (r.customAttributeAttestation || '') : (r.selectionAttestation || ''),
        assess2024:  r.assessScore2024 || '',
        signoff:     signoff.get(key) ? 'Yes' : 'No',
      };
    });

    return {
      name: orgName || `Org ${orgID}`,
      columns,
      rows: excelRows,
      freezeHeader: true,
      editableHeaders,
      editableHeaderColor: 'FFFDE68A',
      // Optional per-column style hint if your Excel helper supports it later
      // but most helpers allow cell-level format at write time:
      // we rely on exportExcel to set wrapText when it sees newline chars
    };
  });

  if (!sheets.length) {
    sheets.push({
      name: 'Export',
      columns,
      rows: [],
      freezeHeader: true,
      editableHeaders,
      editableHeaderColor: 'FFFDE68A',
    });
  }

  return sheets;
}

/* helpers */
function dedupeBy(arr, keyFn) {
  const seen = new Set();
  return arr.filter(x => {
    const k = keyFn(x);
    if (seen.has(k)) return false;
    seen.add(k);
    return true;
  });
}
