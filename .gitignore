import * as React from "react";
import { useMemo, useRef, useState } from "react";
import {
  ThemeProvider,
  createTheme,
  CssBaseline,
  Container,
  Grid,
  Card,
  CardContent,
  Typography,
  Button,
  ButtonGroup,
  Box,
  Chip,
  TextField,
  Switch,
  FormControlLabel,
  Select,
  MenuItem,
  InputLabel,
  FormControl,
  Tabs,
  Tab,
  Divider,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Drawer,
  List,
  ListItemButton,
  ListItemText,
  Stack,
  Tooltip,
  Snackbar,
  Alert,
  useMediaQuery
} from "@mui/material";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import SaveIcon from "@mui/icons-material/Save";
import VisibilityIcon from "@mui/icons-material/Visibility";
import PictureAsPdfIcon from "@mui/icons-material/PictureAsPdf";
import DescriptionIcon from "@mui/icons-material/Description";

// Theme with blue primary
const theme = createTheme({
  palette: {
    mode: "light",
    primary: { main: "#1976d2" },
  },
  shape: { borderRadius: 12 },
  typography: { fontSize: 14 },
});

// --- CSF 2.0 Test Data ---
const SUBCATS = [
  "GV.RR-01",
  "PR.AA-01",
  "PR.AT-01",
  "PR.DS-01",
  "PR.PS-01",
  "DE.AE-02",
  "DE.AE-03",
  "RS.MI-01",
  "RC.RP-01",
  "ID.IM-01",
];

const definitions = {
  "GV.RR-01": "Organizational leadership is responsible and accountable for cybersecurity risk.",
  "PR.AA-01": "Identities and credentials are managed.",
  "PR.AT-01": "Personnel are provided awareness and training.",
  "PR.DS-01": "Data-at-rest is protected.",
  "PR.PS-01": "Configuration management practices are established.",
  "DE.AE-02": "Potentially adverse events are analyzed.",
  "DE.AE-03": "Information is correlated from multiple sources.",
  "RS.MI-01": "Incidents are contained.",
  "RC.RP-01": "Recovery portion of incident response executed.",
  "ID.IM-01": "Improvements are identified from evaluations.",
};

const makeArtifacts = (count, sc, lvl) =>
  Array.from({ length: count }, (_, i) => ({
    id: `${sc}-${lvl}-A${i + 1}`,
    title: `Artifact ${i + 1} for ${sc}`,
    url: `https://example.com/artifacts/${sc}/${lvl}/${i + 1}`,
  }));

const fakeDB = { orgs: ["VCS", "TPD", "NETWORK"], subcategories: SUBCATS, maturity: {} };
SUBCATS.forEach((sc) => {
  fakeDB.maturity[sc] = {
    L3: [
      { id: `${sc}-L3-1`, title: `Attribute 1`, definition: `${definitions[sc]} (baseline L3).`, artifacts: makeArtifacts(2, sc, "L3") },
      { id: `${sc}-L3-2`, title: `Attribute 2`, definition: `Documented process for ${sc}.`, artifacts: makeArtifacts(2, sc, "L3") },
    ],
    L4: [
      { id: `${sc}-L4-1`, title: `Attribute 1`, definition: `Metrics-driven improvement for ${sc}.`, artifacts: makeArtifacts(3, sc, "L4") },
      { id: `${sc}-L4-2`, title: `Attribute 2`, definition: `Proactive validation for ${sc}.`, artifacts: makeArtifacts(2, sc, "L4") },
      { id: `${sc}-L4-3`, title: `Attribute 3`, definition: `Integration with enterprise risk metrics for ${sc}.`, artifacts: makeArtifacts(2, sc, "L4") },
    ],
  };
});

function MultiSelect({ label, options, selected, onChange }) {
  return (
    <FormControl fullWidth size="small">
      <InputLabel id={`${label}-label`}>{label}</InputLabel>
      <Select
        labelId={`${label}-label`}
        multiple
        value={selected}
        onChange={(e) => onChange(e.target.value)}
        renderValue={(sel) => (
          <Box sx={{ display: "flex", flexWrap: "wrap", gap: 0.5 }}>
            {sel.map((v) => <Chip key={v} label={v} size="small" />)}
          </Box>
        )}
      >
        {options.map((opt) => <MenuItem key={opt} value={opt}>{opt}</MenuItem>)}
      </Select>
    </FormControl>
  );
}

function AttributeBlock({ attr, value, onChange }) {
  return (
    <Accordion disableGutters sx={{ borderRadius: 2 }}>
      <AccordionSummary expandIcon={<ExpandMoreIcon />}>
        <Stack spacing={0.5}>
          <Typography fontWeight={600}>{attr.title}</Typography>
          <Typography variant="body2" color="text.secondary">{attr.definition}</Typography>
        </Stack>
      </AccordionSummary>
      <AccordionDetails>
        <Stack spacing={2}>
          <List dense>
            {attr.artifacts.map((a) => (
              <ListItemButton key={a.id} component="a" href={a.url} target="_blank">
                <ListItemText primary={a.title} secondary={a.url} />
              </ListItemButton>
            ))}
          </List>
          <TextField
            label="User comment"
            fullWidth
            size="small"
            multiline
            minRows={3}
            value={value || ""}
            onChange={(e) => onChange(e.target.value)}
          />
        </Stack>
      </AccordionDetails>
    </Accordion>
  );
}

export default function App() {
  const isSmall = useMediaQuery(theme.breakpoints.down("md"));
  const [org, setOrg] = useState("VCS");
  const [subcats, setSubcats] = useState(["GV.RR-01", "DE.AE-02"]);
  const [execSum, setExecSum] = useState("Exec summary...");
  const [scope, setScope] = useState("Scope...");
  const [quant, setQuant] = useState(false);
  const [coverage, setCoverage] = useState("Qualitative coverage...");
  const [pct, setPct] = useState(80);
  const [comments, setComments] = useState({});
  const [tab, setTab] = useState("L3");
  const [previewOpen, setPreviewOpen] = useState(false);

  const narrative = useMemo(() => {
    return `Narrative for ${org}`;
  }, [org]);

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Container maxWidth="xl" sx={{ py: 2 }}>
        <Grid container spacing={2}>
          <Grid item xs={12} md={4}>
            <Card sx={{ height: "100%" }}>
              <CardContent>
                <Stack spacing={2}>
                  <ButtonGroup fullWidth orientation={isSmall ? "vertical" : "horizontal"}>
                    {fakeDB.orgs.map((o) => (
                      <Button key={o} variant={org === o ? "contained" : "outlined"} onClick={() => setOrg(o)}>
                        {o}
                      </Button>
                    ))}
                  </ButtonGroup>
                  <MultiSelect label="Subcategories" options={fakeDB.subcategories} selected={subcats} onChange={setSubcats} />
                  <TextField label="Executive Summary" value={execSum} onChange={(e) => setExecSum(e.target.value)} multiline minRows={3} fullWidth />
                  <TextField label="Scope" value={scope} onChange={(e) => setScope(e.target.value)} multiline minRows={2} fullWidth />
                  <FormControlLabel control={<Switch checked={quant} onChange={(e) => setQuant(e.target.checked)} />} label={quant ? "Quantitative" : "Qualitative"} />
                  {!quant ? (
                    <TextField label="Coverage" value={coverage} onChange={(e) => setCoverage(e.target.value)} multiline minRows={2} fullWidth />
                  ) : (
                    <TextField label="Coverage %" type="number" value={pct} onChange={(e) => setPct(Number(e.target.value))} fullWidth />
                  )}
                </Stack>
              </CardContent>
            </Card>
          </Grid>

          <Grid item xs={12} md={8}>
            <Card>
              <CardContent>
                <Tabs value={tab} onChange={(_, v) => setTab(v)} variant="scrollable">
                  <Tab value="L3" label="Level 3" />
                  <Tab value="L4" label="Level 4" />
                </Tabs>
                <Divider sx={{ my: 2 }} />
                <Stack spacing={2}>
                  {subcats.map((sc) => (
                    <Box key={sc}>
                      <Typography variant="h6">{sc}: {definitions[sc]}</Typography>
                      {fakeDB.maturity[sc][tab].map((attr) => {
                        const key = `${sc}|${tab}|${attr.id}`;
                        return <AttributeBlock key={key} attr={attr} value={comments[key]} onChange={(v) => setComments((c) => ({ ...c, [key]: v }))} />;
                      })}
                    </Box>
                  ))}
                </Stack>
              </CardContent>
            </Card>
          </Grid>
        </Grid>

        <Dialog open={previewOpen} onClose={() => setPreviewOpen(false)} fullScreen={isSmall} maxWidth="md" fullWidth>
          <DialogTitle>Preview</DialogTitle>
          <DialogContent>
            <Typography>{narrative}</Typography>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setPreviewOpen(false)}>Close</Button>
          </DialogActions>
        </Dialog>
      </Container>
    </ThemeProvider>
  );
}
