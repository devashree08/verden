import os
import queue
from typing import Any, Dict, List, Optional

import pyodbc
from dotenv import load_dotenv

load_dotenv()

def _conn_str() -> str:
    driver = os.getenv("SQLSERVER_DRIVER", "ODBC Driver 18 for SQL Server")
    server = os.getenv("SQLSERVER_SERVER")
    database = os.getenv("SQLSERVER_DATABASE")
    encrypt = os.getenv("SQLSERVER_ENCRYPT", "yes")
    tsc = os.getenv("SQLSERVER_TRUSTCERT", "no")
    if not server or not database:
        raise RuntimeError("Missing SQL Server env vars; check .env")
    return f"Driver={{{driver}}};Server={server};Database={database};Encrypt={encrypt};TrustServerCertificate={tsc};".format(driver=driver)

CONN_STR = _conn_str()
UID = os.getenv("SQLSERVER_UID")
PWD = os.getenv("SQLSERVER_PWD")
POOL_SIZE = int(os.getenv("POOL_SIZE", "8"))

class ODBCConnectionPool:
    def __init__(self, size: int):
        self._q: "queue.Queue[pyodbc.Connection]" = queue.Queue(maxsize=size)
        for _ in range(size):
            cn = pyodbc.connect(CONN_STR, user=UID, password=PWD, autocommit=True, timeout=30)
            self._q.put(cn)
    def get(self) -> pyodbc.Connection:
        return self._q.get()
    def put(self, cn: pyodbc.Connection) -> None:
        self._q.put(cn)

def get_proc_parameters(pool: ODBCConnectionPool, schema: str, proc: str) -> List[Dict[str, Any]]:
    """Return input+output parameters for [schema].[proc]."""
    cn = pool.get()
    try:
        cur = cn.cursor()
        cur.execute("""
            SELECT p.parameter_id AS ordinal,
                   REPLACE(p.name,'@','') AS name,
                   p.is_output,
                   t.name AS sql_type,
                   p.max_length, p.precision, p.scale,
                   p.has_default_value
            FROM sys.parameters p
            JOIN sys.types t ON p.user_type_id = t.user_type_id
            WHERE p.object_id = OBJECT_ID(?)
            ORDER BY p.parameter_id;
        """, (f"[{schema}].[{proc}]",))
        return [{
            "ordinal": r[0],
            "name": r[1],
            "is_output": bool(r[2]),
            "sql_type": r[3].lower(),
            "max_length": r[4],
            "precision": r[5],
            "scale": r[6],
            "has_default": bool(r[7]),
        } for r in cur.fetchall()]
    finally:
        pool.put(cn)

def _coerce(sql_type: str, value: Any) -> Any:
    if value is None:
        return None
    t = sql_type.lower()
    if t in ("int", "smallint", "tinyint", "bigint"):
        return int(value)
    if t == "bit":
        return str(value).strip().lower() in ("1", "true", "yes")
    if t in ("decimal", "numeric", "float"):
        return float(value)
    return str(value)

def exec_proc(
    pool: ODBCConnectionPool,
    schema: str,
    proc: str,
    args: Dict[str, Any],
    required_overrides: Optional[Dict[str, bool]] = None,
) -> List[Dict[str, Any]]:
    """Execute a stored proc with named args; return SELECT rows."""
    cn = pool.get()
    try:
        cur = cn.cursor()
        meta = get_proc_parameters(pool, schema, proc)
        inputs = [p for p in meta if not p["is_output"]]
        bound: List[Any] = []
        for p in sorted(inputs, key=lambda x: x["ordinal"]):
            name = p["name"]
            required = (required_overrides or {}).get(name, not p["has_default"])
            if name not in args or args[name] is None:
                if required:
                    raise KeyError(name)
                bound.append(None)
            else:
                bound.append(_coerce(p["sql_type"], args[name]))
        call = f"{{CALL [{schema}].[{proc}] ({', '.join('?' for _ in bound)})}}" if bound else f"{{CALL [{schema}].[{proc}]}}"
        cur.execute(call, tuple(bound))
        cols = [c[0] for c in cur.description] if cur.description else []
        return [dict(zip(cols, r)) for r in cur.fetchall()] if cols else []
    finally:
        pool.put(cn)

def describe_first_result_set(pool: ODBCConnectionPool, schema: str, proc: str) -> List[Dict[str, Any]]:
    """
    Column contract (no data): sys.dm_exec_describe_first_result_set_for_object on the proc object.
    Returns [{ordinal, name, system_type, is_nullable, max_length, precision, scale}, ...]
    """
    cn = pool.get()
    try:
        cur = cn.cursor()
        full = f"[{schema}].[{proc}]"
        cur.execute("""
            SELECT
              d.column_ordinal,
              d.name,
              d.system_type_name,
              d.is_nullable,
              d.max_length,
              d.precision,
              d.scale
            FROM sys.dm_exec_describe_first_result_set_for_object(OBJECT_ID(?), NULL) AS d
            WHERE d.error_number IS NULL
            ORDER BY d.column_ordinal;
        """, (full,))
        out: List[Dict[str, Any]] = []
        for r in cur.fetchall():
            out.append({
                "ordinal": r[0],
                "name": r[1],
                "system_type": (r[2] or "").lower(),
                "is_nullable": bool(r[3]),
                "max_length": r[4],
                "precision": r[5],
                "scale": r[6],
            })
        return out
    finally:
        pool.put(cn)








import os
import json
import re
from typing import Any, Dict, List, Optional

from db import ODBCConnectionPool, get_proc_parameters, describe_first_result_set

# ---------- Registry I/O ----------

def load_registry(path: str) -> Dict[str, Any]:
    if not os.path.exists(path):
        raise FileNotFoundError(f"Registry not found: {path}")
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

# ---------- Param contract (auto from SQL, tiny overrides optional) ----------

_SQL_TO_OA: Dict[str, tuple[str, Optional[str]]] = {
    "int": ("integer", "int32"),
    "bigint": ("integer", "int64"),
    "smallint": ("integer", "int32"),
    "tinyint": ("integer", "int32"),
    "bit": ("boolean", None),
    "decimal": ("number", "double"),
    "numeric": ("number", "double"),
    "float": ("number", "double"),
    # others default to string
}

def _is_string(sql: str) -> bool:
    return sql in ("varchar", "nvarchar", "char", "nchar", "text", "ntext", "uniqueidentifier", "sysname")

def _oa_type_fmt(sql: str) -> Dict[str, Any]:
    base = sql.split("(", 1)[0].strip().lower()
    typ, fmt = _SQL_TO_OA.get(base, ("string", None))
    d: Dict[str, Any] = {"type": typ}
    if fmt:
        d["format"] = fmt
    return d

def _maxlen_for_string(sql: str, max_len: Optional[int]) -> Optional[int]:
    if max_len is None:
        return None
    base = sql.split("(", 1)[0].strip().lower()
    if not _is_string(base):
        return None
    if max_len < 0:  # (MAX)
        return 4000
    if base in ("nvarchar", "nchar"):
        return max_len // 2
    return max_len

# exclude '<' '>' so JSON doesn't escape them to \u003C \u003E
_ASCII_WHITELIST = r"A-Za-z0-9\s\.,;:'\"@#\$%\^&\*\(\)\[\]\{\}\-_\/\+\=\?!`~\|"

def _default_pattern_for_type(name: str, sql: str) -> Optional[str]:
    base = sql.split("(", 1)[0].strip().lower()
    n = name.lower()
    if base in ("int","bigint","smallint","tinyint"):
        return r"^-?\d+$"
    if base in ("decimal","numeric","float"):
        return r"^-?\d+(\.\d+)?$"
    if base == "bit":
        return r"^(?:0|1|true|false)$"
    if base == "date":
        return r"^\d{4}-\d{2}-\d{2}$"
    if base in ("datetime","datetime2","smalldatetime"):
        return r"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}(:\d{2}(\.\d{1,7})?)?$"
    if base == "uniqueidentifier":
        return r"^[0-9a-fA-F-]{36}$"
    if _is_string(base) and (n.endswith("ids") or "id_list" in n or "ids_list" in n or "appids" in n):
        return r"^\s*\d+(?:\s*,\s*\d+)*\s*$"
    if _is_string(base):
        return rf"^[{_ASCII_WHITELIST}]*$"
    return None

def build_param_contract(
    pool: ODBCConnectionPool,
    schema: str,
    proc: str,
    method: str,
    overrides: Optional[List[Dict[str, Any]]] = None,
) -> List[Dict[str, Any]]:
    meta = get_proc_parameters(pool, schema, proc)
    inputs = [m for m in meta if not m["is_output"]]
    ov = {p["name"]: p for p in (overrides or []) if p.get("name")}
    out: List[Dict[str, Any]] = []
    for p in inputs:
        name = p["name"]; sql = p["sql_type"]; ml = p["max_length"]
        where = ("query" if method.upper() == "GET" else "body")
        if name in ov and ov[name].get("in") in ("query","body"):
            where = ov[name]["in"]
        oa = _oa_type_fmt(sql)
        spec: Dict[str, Any] = {
            "name": name,
            "in": where,
            "type": oa["type"],
            "required": bool(ov.get(name, {}).get("required", not p["has_default"]))
        }
        if "format" in oa:
            spec["format"] = oa["format"]
        if spec["type"] == "string":
            mx = _maxlen_for_string(sql, ml)
            if isinstance(mx, int):
                spec["maxLength"] = mx
        pat = _default_pattern_for_type(name, sql)
        if pat:
            spec["pattern"] = pat
        # allow explicit overrides
        for k in ("maxLength","pattern","format","minLength","enum","description"):
            if name in ov and k in ov[name]:
                spec[k] = ov[name][k]
        out.append(spec)

    # include registry-only params (if any)
    for name, r in ov.items():
        if name in {m["name"] for m in inputs}:
            continue
        where = r.get("in") or ("query" if method.upper()=="GET" else "body")
        spec = {"name": name, "in": where, "type": r.get("type","string"), "required": bool(r.get("required", False))}
        for k in ("maxLength","pattern","format","minLength","enum","description"):
            if k in r: spec[k] = r[k]
        out.append(spec)

    return out

def required_overrides_from_specs(specs: List[Dict[str, Any]]) -> Dict[str, bool]:
    return {s["name"]: bool(s.get("required", False)) for s in specs}

def validate_params(specs: List[Dict[str, Any]], carrier: Dict[str, Any], source: str) -> List[str]:
    errs: List[str] = []
    for s in specs:
        if s["in"] != source:
            continue
        name = s["name"]; required = bool(s.get("required", False))
        val = carrier.get(name)
        if val is None:
            if required:
                errs.append(f"E_MISSING_{name.upper()}")
            continue
        v = str(val)
        if "maxLength" in s:
            try:
                if len(v) > int(s["maxLength"]):
                    errs.append(f"E_PARAM_MAXLEN_{name.upper()}")
            except Exception:
                errs.append(f"E_PARAM_MAXLEN_{name.upper()}")
        if "minLength" in s:
            try:
                if len(v) < int(s["minLength"]):
                    errs.append(f"E_PARAM_MINLEN_{name.upper()}")
            except Exception:
                errs.append(f"E_PARAM_MINLEN_{name.upper()}")
        if "pattern" in s and s["pattern"]:
            try:
                if not re.fullmatch(s["pattern"], v):
                    errs.append(f"E_PARAM_PATTERN_{name.upper()}")
            except re.error:
                errs.append(f"E_PARAM_PATTERN_{name.upper()}")
        if "enum" in s and isinstance(s["enum"], list):
            if v not in [str(x) for x in s["enum"]]:
                errs.append(f"E_PARAM_ENUM_{name.upper()}")
    return errs

# ---------- Response Model (DTO) ----------

def _pascal(s: str) -> str:
    s = re.sub(r"[^a-zA-Z0-9]+", " ", str(s))
    return "".join(w[:1].upper() + w[1:] for w in s.split() if w)

def _model_name(ep: Dict[str, Any]) -> str:
    base = ep.get("modelName") or ep.get("proc") or ep["path"]
    return f"{_pascal(base)}Model"

def _oa_for_system_type(system_type: str) -> Dict[str, Any]:
    base = system_type.split("(",1)[0].strip().lower()
    if base in ("int","smallint","tinyint"): return {"type":"integer","format":"int32","pattern": r"^-?\d+$"}
    if base == "bigint": return {"type":"integer","format":"int64","pattern": r"^-?\d+$"}
    if base in ("decimal","numeric","float"): return {"type":"number","format":"double","pattern": r"^-?\d+(\.\d+)?$"}
    if base == "bit": return {"type":"boolean","pattern": r"^(?:0|1|true|false)$"}
    if base == "date": return {"type":"string","format":"date","pattern": r"^\d{4}-\d{2}-\d{2}$"}
    if base in ("datetime","datetime2","smalldatetime"): return {"type":"string","format":"date-time","pattern": r"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}(:\d{2}(\.\d{1,7})?)?$"}
    if base == "uniqueidentifier": return {"type":"string","pattern": r"^[0-9a-fA-F-]{36}$"}
    return {"type":"string","pattern": rf"^[{_ASCII_WHITELIST}]*$"}

def _sanitize_col_name(name: Optional[str], ordinal: int) -> str:
    """Keep SQL's column name verbatim when provided; synthesize only if NULL/empty."""
    if name is None:
        return f"col{ordinal}"
    s = str(name).replace("\r", " ").replace("\n", " ").strip()
    return s if s else f"col{ordinal}"

def build_response_model(pool: ODBCConnectionPool, ep: Dict[str, Any]) -> Dict[str, Any]:
    cols = describe_first_result_set(pool, ep["schema"], ep["proc"])
    row_props: Dict[str, Any] = {}
    required_cols: List[str] = []
    for c in cols:
        col_name = _sanitize_col_name(c.get("name"), c["ordinal"])
        col_schema = _oa_for_system_type(c["system_type"])
        base = c["system_type"].split("(",1)[0].strip().lower()
        if base in ("varchar","nvarchar","char","nchar"):
            ml = c.get("max_length")
            if isinstance(ml, int) and ml >= 0:
                col_schema["maxLength"] = (ml // 2) if base in ("nvarchar","nchar") else ml
            elif isinstance(ml, int) and ml < 0:
                col_schema["maxLength"] = 4000
        col_schema["nullable"] = bool(c.get("is_nullable", True))
        if not col_schema["nullable"]:
            required_cols.append(col_name)
        row_props[col_name] = col_schema

    row_schema: Dict[str, Any] = {"type":"object","properties": row_props, "additionalProperties": True}
    if required_cols:
        row_schema["required"] = required_cols

    model_name = _model_name(ep)
    return {
        "name": model_name,
        "schema": {
            "type": "object",
            "additionalProperties": False,
            "properties": {
                "rows": {"type": "array", "items": row_schema}
            }
        }
    }

# ---------- OpenAPI enrichment ----------

def enrich_openapi(spec: Dict[str, Any], endpoints: List[Dict[str, Any]], pool: ODBCConnectionPool) -> Dict[str, Any]:
    spec["openapi"] = "3.1.0"
    spec.setdefault("servers", [{"url": "/"}])

    comps = spec.setdefault("components", {})
    schemas = comps.setdefault("schemas", {})

    # ErrorResponse (42C)
    schemas["ErrorResponse"] = {
        "type":"object","additionalProperties":False,
        "properties":{"fault":{"type":"object","additionalProperties":False,"properties":{
            "faultstring":{"type":"string"},
            "detail":{"oneOf":[
                {"type":"object","properties":{"errorcode":{"type":"string"}},"additionalProperties":False},
                {"type":"array","maxItems":10,"items":{"type":"object","properties":{"errorcode":{"type":"string"}},"additionalProperties":False}}
            ]}
        }}}
    }

    # Security
    spec["components"].setdefault("securitySchemes", {})
    spec["components"]["securitySchemes"]["apiKeyAuth"] = {"type":"apiKey","in":"header","name":"X-API-Key"}
    spec["security"] = [{"apiKeyAuth": []}]

    def add_common_errors(op: Dict[str, Any], method: str) -> None:
        for sc in (["400","401","403","404","500"] + (["415"] if method == "POST" else [])):
            op.setdefault("responses", {}).setdefault(
                sc,
                {"description":"", "content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorResponse"}}}},
            )

    for ep in endpoints:
        path = ep["path"]; method = ep["method"].upper()
        specs_list = build_param_contract(pool, ep["schema"], ep["proc"], method, ep.get("params"))
        resp = build_response_model(pool, ep)
        schemas[resp["name"]] = resp["schema"]

        if method == "GET":
            op = spec.get("paths", {}).get(path, {}).get("get")
            if not op:
                continue
            # parameters (query)
            params = []
            for s in specs_list:
                if s["in"] != "query":
                    continue
                sch: Dict[str, Any] = {"type": s["type"]}
                if "format" in s: sch["format"] = s["format"]
                for k in ("maxLength","minLength","pattern","enum"):
                    if k in s: sch[k] = s[k]
                params.append({
                    "name": s["name"], "in": "query",
                    "required": bool(s.get("required", False)),
                    "schema": sch,
                    "description": s.get("description","")
                })
            op["parameters"] = params
            op.setdefault("responses", {})["200"] = {
                "description": "OK",
                "content": {"application/json": {"schema": {"$ref": f"#/components/schemas/{resp['name']}"}}}
            }
            add_common_errors(op, "GET")

        elif method == "POST":
            op = spec.get("paths", {}).get(path, {}).get("post")
            if not op:
                continue
            # request body (strict)
            props: Dict[str, Any] = {}
            required_props: List[str] = []
            for s in specs_list:
                if s["in"] != "body":
                    continue
                sch: Dict[str, Any] = {"type": s["type"]}
                if "format" in s: sch["format"] = s["format"]
                for k in ("maxLength","minLength","pattern","enum"):
                    if k in s: sch[k] = s[k]
                props[s["name"]] = sch
                if s.get("required", False):
                    required_props.append(s["name"])
            op["requestBody"] = {
                "required": True,
                "content": {"application/json": {"schema": {
                    "type":"object","properties": props,"required": required_props, "additionalProperties": False
                }}}
            }
            op.setdefault("responses", {})["200"] = {
                "description": "OK",
                "content": {"application/json": {"schema": {"$ref": f"#/components/schemas/{resp['name']}"}}}
            }
            add_common_errors(op, "POST")

    return spec









import os
from typing import Any, Dict, List
from contextlib import asynccontextmanager

from dotenv import load_dotenv
from fastapi import FastAPI, APIRouter, Request, Depends, Body, HTTPException
from fastapi.responses import JSONResponse
from fastapi.openapi.utils import get_openapi

from db import ODBCConnectionPool, exec_proc, POOL_SIZE
from contract import load_registry, build_param_contract, required_overrides_from_specs, validate_params, enrich_openapi

load_dotenv()

API_KEY = os.getenv("API_KEY", "super-secret-key")
REGISTRY_PATH = os.getenv("REGISTRY_PATH", "./procs.registry.json")

def require_api_key(request: Request) -> None:
    if request.headers.get("X-API-Key") != API_KEY:
        raise HTTPException(status_code=401, detail={"fault":{"faultstring":"Unauthorized","detail":{"errorcode":"E_UNAUTHORIZED"}}})

def error_response(code: int, msg: str, codes: str | List[str]) -> JSONResponse:
    detail = [{"errorcode": c} for c in codes] if isinstance(codes, list) else {"errorcode": codes}
    return JSONResponse(status_code=code, content={"fault":{"faultstring": msg, "detail": detail}})

@asynccontextmanager
async def lifespan(app: FastAPI):
    app.state.pool = ODBCConnectionPool(size=POOL_SIZE)
    app.state.registry = load_registry(REGISTRY_PATH)
    register_from_registry(app)
    yield

app = FastAPI(
    title=os.getenv("API_TITLE", "ProcBridge API"),
    version=os.getenv("API_VERSION", "1.0.0"),
    description="Expose selected stored procedures as REST with a clean OpenAPI contract (42Crunch-friendly).",
    lifespan=lifespan,
)

router = APIRouter()

def register_from_registry(app: FastAPI) -> None:
    for ep in app.state.registry.get("endpoints", []):
        register_endpoint(app, ep)
    app.include_router(router)

def register_endpoint(app: FastAPI, ep: Dict[str, Any]) -> None:
    schema, proc, path, method = ep["schema"], ep["proc"], ep["path"], ep["method"].upper()
    summary, description = ep.get("summary", f"Execute {schema}.{proc}"), ep.get("description", "")

    async def handle_get(request: Request, _auth=Depends(require_api_key)):
        pool: ODBCConnectionPool = request.app.state.pool
        specs = build_param_contract(pool, schema, proc, "GET", ep.get("params"))
        query = dict(request.query_params)
        errs = validate_params(specs, query, "query")
        if errs:
            return error_response(400, "Bad Request", errs[:10])
        args = {s["name"]: query.get(s["name"]) for s in specs if s["in"] == "query" and s["name"] in query}
        try:
            rows = exec_proc(pool, schema, proc, args, required_overrides=required_overrides_from_specs(specs))
            return {"rows": rows}
        except KeyError as k:
            return error_response(400, "Bad Request", f"E_MISSING_{str(k).strip('\"').upper()}")
        except Exception:
            return error_response(500, "Server error", "E_SERVER")

    async def handle_post(payload: Dict[str, Any] = Body(...), request: Request = None, _auth=Depends(require_api_key)):
        if not isinstance(payload, dict):
            return error_response(400, "Bad Request", "E_BODY_NOT_OBJECT")
        pool: ODBCConnectionPool = request.app.state.pool
        specs = build_param_contract(pool, schema, proc, "POST", ep.get("params"))
        errs = validate_params(specs, payload, "body")
        if errs:
            return error_response(400, "Bad Request", errs[:10])
        try:
            rows = exec_proc(pool, schema, proc, payload, required_overrides=required_overrides_from_specs(specs))
            return {"rows": rows}
        except KeyError as k:
            return error_response(400, "Bad Request", f"E_MISSING_{str(k).strip('\"').upper()}")
        except Exception:
            return error_response(500, "Server error", "E_SERVER")

    if method == "GET":
        router.add_api_route(path, handle_get, methods=["GET"], name=f"{schema}.{proc}", summary=summary, description=description)
    elif method == "POST":
        router.add_api_route(path, handle_post, methods=["POST"], name=f"{schema}.{proc}", summary=summary, description=description)
    else:
        raise RuntimeError(f"Unsupported method '{method}'. Use GET or POST.")

def custom_openapi() -> Dict[str, Any]:
    spec = get_openapi(title=app.title, version=app.version, description=app.description, routes=app.routes)
    return enrich_openapi(spec, app.state.registry.get("endpoints", []), app.state.pool)

app.openapi = custom_openapi

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=False)





