def enrich_openapi(spec: Dict[str, Any], endpoints: List[Dict[str, Any]], pool: ODBCConnectionPool) -> Dict[str, Any]:
    spec["openapi"] = "3.1.0"

    # servers (optional but useful for scans)
    spec.setdefault("servers", [{"url": "/"}])

    comps = spec.setdefault("components", {}).setdefault("schemas", {})
    comps["ErrorResponse"] = {
        "type":"object","additionalProperties":False,
        "properties":{
            "fault":{
                "type":"object","additionalProperties":False,
                "properties":{
                    "faultstring":{"type":"string"},
                    "detail":{
                        "oneOf":[
                            {"type":"object","properties":{"errorcode":{"type":"string"}},"additionalProperties":False},
                            {"type":"array","maxItems":10,"items":{"type":"object","properties":{"errorcode":{"type":"string"}},"additionalProperties":False}}
                        ]
                    }
                }
            }
        }
    }

    # Security
    spec["components"].setdefault("securitySchemes", {})
    spec["components"]["securitySchemes"]["apiKeyAuth"] = {"type":"apiKey","in":"header","name":"X-API-Key"}
    spec["security"] = [{"apiKeyAuth": []}]

    def attach_common_errors(op: Dict[str, Any], method: str):
        # Always include 400 (client input), 401/403 (since security is applied), 404 (not found), 415 (bad media for POST), 500
        errors = ["400", "401", "403", "404", "500"]
        if method == "POST":
            errors.append("415")
        for sc in errors:
            op.setdefault("responses", {}).setdefault(
                sc,
                {"description":"", "content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorResponse"}}}},
            )

    for ep in endpoints:
        schema, proc, path, method = ep["schema"], ep["proc"], ep["path"], ep["method"].upper()
        reg_params = ep.get("params", None)
        specs_list = build_param_contract(pool, schema, proc, method, reg_params)
        response_model = ep.get("response")

        if method == "GET":
            try:
                getop = spec["paths"][path]["get"]
            except KeyError:
                continue
            # Query parameters from auto-contract
            params = []
            for s in specs_list:
                if s["in"] != "query": 
                    continue
                sch: Dict[str, Any] = {"type": s["type"]}
                for k in ("maxLength","minLength","pattern","format","enum","example"):
                    if k in s: sch[k] = s[k]
                params.append({
                    "name": s["name"],
                    "in": "query",
                    "required": bool(s.get("required", False)),
                    "schema": sch,
                    "description": s.get("description","")
                })
            getop["parameters"] = params

            # 200 response
            if response_model and isinstance(response_model, dict):
                getop.setdefault("responses", {}).setdefault(
                    "200", {"description":"OK","content":{"application/json":{"schema": response_model}}}
                )
            else:
                # fallback: generic rows array (dev can tighten later in registry)
                getop.setdefault("responses", {}).setdefault(
                    "200", {"description":"OK","content":{"application/json":{"schema":{
                        "type":"object","additionalProperties":False,
                        "properties":{"rows":{"type":"array","items":{"type":"object","additionalProperties":True}}}
                    }}}}
                )

            attach_common_errors(getop, "GET")

        elif method == "POST":
            try:
                postop = spec["paths"][path]["post"]
            except KeyError:
                continue
            # requestBody from body params
            props: Dict[str, Any] = {}
            required_props: List[str] = []
            for s in specs_list:
                if s["in"] != "body": 
                    continue
                sch: Dict[str, Any] = {"type": s["type"]}
                for k in ("maxLength","minLength","pattern","format","enum","example"):
                    if k in s: sch[k] = s[k]
                props[s["name"]] = sch
                if s.get("required", False):
                    required_props.append(s["name"])
            postop["requestBody"] = {
                "required": True,
                "content": {"application/json": {"schema":{
                    "type":"object","properties":props,"required":required_props,"additionalProperties":False
                }}}
            }

            # 200 response
            if response_model and isinstance(response_model, dict):
                postop.setdefault("responses", {}).setdefault(
                    "200", {"description":"OK","content":{"application/json":{"schema": response_model}}}
                )
            else:
                postop.setdefault("responses", {}).setdefault(
                    "200", {"description":"OK","content":{"application/json":{"schema":{
                        "type":"object","additionalProperties":False,
                        "properties":{"rows":{"type":"array","items":{"type":"object","additionalProperties":True}}}
                    }}}}
                )

            attach_common_errors(postop, "POST")

    return spec
