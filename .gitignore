// /features/attributeMapping/utils/exportAttributeMappingExcel.js
import { exportExcel } from '../../../ui/data/ExcelExport';
import { fetchAttributeFeed } from '../api/attributeApi';
import { normalizeHeaders, normalizeRows } from '../utils/normalizeFeed';
import { buildSheetsForAttributeMapping } from './buildSheetsForAttributeMapping';

/**
 * exportAttributeMappingExcel({ filters, selectedSubcatID, fileName })
 * - If selectedSubcatID is present -> export just that subcat scope
 * - Else, export all subcats under current filters (build subcat list from headers)
 * - Per-org sheet, even when org has 0 rows
 */
export async function exportAttributeMappingExcel({ filters, selectedSubcatID, fileName }) {
  // 1) pull headers for the current filters (finalOnly=false so we get everything)
  const headerResp = await fetchAttributeFeed({
    functionIds:    filters.functionIds,
    categoryIds:    filters.categoryIds,
    subcatIds:      filters.subcatIds,       // may be empty
    ownerNames:     filters.ownerNames,
    custodianNames: filters.custodianNames,
    maturity:       filters.maturity,
    finalOnly:      false,
    search:         filters.search,
  });
  const headers = normalizeHeaders(headerResp.headers || []);

  // figure out which subcats to request rows for
  let subcatIdsWanted = [];
  if (selectedSubcatID) {
    subcatIdsWanted = [selectedSubcatID];
  } else if (filters.subcatIds?.length) {
    subcatIdsWanted = filters.subcatIds;
  } else {
    // all subcats visible in headers (so we get all rows for all orgs under the current filters)
    const set = new Set(headers.map(h => String(h.csF2SubcategoryID)));
    subcatIdsWanted = Array.from(set);
  }

  // 2) pull rows for those subcats (your SP requires subcatIds to return rows)
  const rowsResp = await fetchAttributeFeed({
    functionIds:    filters.functionIds,
    categoryIds:    filters.categoryIds,
    subcatIds:      subcatIdsWanted,
    ownerNames:     filters.ownerNames,
    custodianNames: filters.custodianNames,
    maturity:       filters.maturity,
    finalOnly:      false,                  // we apply "Final View" locally
    search:         filters.search,
  });
  const rows = normalizeRows(rowsResp.rows || []);

  // 3) build sheets + export
  const sheets = buildSheetsForAttributeMapping({
    headers,
    rows,
    finalOnly: !!filters.finalOnly,
  });

  await exportExcel({
    fileName: fileName || `CSF-Attribute-Mapping ${new Date().toISOString().slice(0,10)}.xlsx`,
    sheets,
  });
}
