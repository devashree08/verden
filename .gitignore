"""
Keycloak OIDC for MCP (enterprise-grade, minimal config).

- Validates Authorization: Bearer <JWT> via FastMCP's JWTVerifier
- Requires an email-style identifier ('email' | 'upn' | 'preferred_username')
- Publishes normalized email into request context state as "email" for tools
"""

from __future__ import annotations
import logging
from typing import Optional

from fastmcp.server.auth.providers.jwt import JWTVerifier
from fastmcp.server.middleware import Middleware, MiddlewareContext
from fastmcp.server.dependencies import get_access_token

from ..core.config import (
    OIDC_JWKS_URI,
    OIDC_ISSUER_URI,
    OIDC_ALLOWED_AUDIENCE,
)

log = logging.getLogger(__name__)


def build_jwt_verifier() -> JWTVerifier:
    if not (OIDC_JWKS_URI and OIDC_ISSUER_URI and OIDC_ALLOWED_AUDIENCE):
        raise RuntimeError(
            "JWT auth misconfigured: OIDC_JWKS_URI, OIDC_ISSUER_URI, and OIDC_ALLOWED_AUDIENCE are required"
        )
    return JWTVerifier(
        jwks_uri=OIDC_JWKS_URI,
        issuer=OIDC_ISSUER_URI,
        audience=OIDC_ALLOWED_AUDIENCE,
    )


class EmailClaimMiddleware(Middleware):
    """
    Extract the caller's email from verified JWT claims and stash in request state.
    Tools can then read it with:  ctx.get_state("email")
    """

    # ---- Primary request hook (where we enforce/attach email) ----
    async def on_request(self, context: MiddlewareContext, call_next):
        token = get_access_token()
        if token is None:
            return await context.fastmcp_context.error("Unauthorized: missing or invalid access token", status=401)

        claims = token.claims or {}
        raw_email: Optional[str] = (
            claims.get("email")
            or claims.get("upn")
            or claims.get("preferred_username")
        )
        if not raw_email:
            return await context.fastmcp_context.error("Forbidden: email claim missing", status=403)

        # Store for tools
        context.fastmcp_context.set_state("email", raw_email.strip().lower())

        return await call_next()

    # ---- Pass-through stubs for list phases (avoid signature mismatches) ----
    async def on_list_tools(self, context: MiddlewareContext, call_next):
        return await call_next()

    async def on_list_resources(self, context: MiddlewareContext, call_next):
        return await call_next()

    async def on_list_prompts(self, context: MiddlewareContext, call_next):
        return await call_next()
