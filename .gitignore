// Tiny wrapper around SheetJS
// npm i xlsx
import * as XLSX from 'xlsx';

/**
 * downloadXlsx({
 *   rows: Array<any>,
 *   columns: [{ header: string, value: (row) => any, width?: number }],
 *   fileName: string,
 *   sheetName?: string
 * })
 */
export function downloadXlsx({ rows, columns, fileName, sheetName = 'Sheet1' }) {
  const headerRow = columns.map(c => c.header);
  const dataRows  = rows.map(r => columns.map(c => c.value(r)));

  const ws = XLSX.utils.aoa_to_sheet([headerRow, ...dataRows]);

  // Column widths
  ws['!cols'] = columns.map(c => ({ wch: c.width ?? 24 }));

  // Freeze header + enable filter
  ws['!freeze'] = { xSplit: 0, ySplit: 1 };
  ws['!autofilter'] = { ref: XLSX.utils.encode_range({
    s: { r: 0, c: 0 },
    e: { r: 0, c: columns.length - 1 }
  })};

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, sheetName);
  XLSX.writeFile(wb, fileName);
}


--

import { downloadXlsx } from '../../../ui/data/xlsxExport';

// helper: completed?
function isCompleted(header) {
  if (!header) return false;
  const cAt = header.completedAt ? new Date(header.completedAt) : null;
  const rAt = header.reopenedAt  ? new Date(header.reopenedAt)  : null;
  return !!(cAt && (!rAt || cAt >= rAt));
}

/**
 * Export rows exactly as requested:
 * Columns:
 *  CSF 2.0 Function | CSF 2.0 Category | CSF 2.0 Subcategory | ML | Attribute # |
 *  Attribute Definition | Status | 2025 Attestation | 2024 Assessor Score | Subcategory Sign-Off?
 *
 * @param {Array} rows        - the currently displayed rows (respect your Final View toggle upstream)
 * @param {Array} headers     - full headers feed (for sign-off lookup)
 * @param {number} orgID      - active org id (sign-off is org-scoped)
 * @param {string} fileName   - e.g. 'CSF-Attribute-Mapping.xlsx'
 */
export function exportAttributeRowsToXlsx(rows, headers, orgID, fileName) {
  // Build (orgID|subcatID) -> header map for sign-off
  const hmap = new Map();
  headers.forEach(h => {
    hmap.set(`${h.orgID}|${h.csF2SubcategoryID}`, h);
  });

  const isCustom = (r) => !!r.customAttributeDefinition;
  const columns = [
    {
      header: 'CSF 2.0 Function',
      width: 28,
      value: (r) => r.functionName || ''
    },
    {
      header: 'CSF 2.0 Category',
      width: 28,
      value: (r) => r.categoryName || ''
    },
    {
      header: 'CSF 2.0 Subcategory',
      width: 26,
      value: (r) => r.csF2SubcategoryName || ''
    },
    {
      header: 'ML',
      width: 6,
      value: (r) => r.maturityLevel ?? ''
    },
    {
      header: 'Attribute #',
      width: 12,
      value: (r) => isCustom(r) ? (r.customAttributeNum ?? '') : (r.attributeNum ?? '')
    },
    {
      header: 'Attribute Definition',
      width: 60,
      value: (r) => isCustom(r) ? (r.customAttributeDefinition || '') : (r.attributeDefinition || '')
    },
    {
      header: 'Status',
      width: 12,
      value: (r) => isCustom(r) ? 'Add' : (r.selectionStatus || '')
    },
    {
      header: '2025 Attestation',
      width: 18,
      value: (r) => isCustom(r) ? (r.customAttributeAttestation || '') : (r.selectionAttestation || '')
    },
    {
      header: '2024 Assessor Score',
      width: 22,
      value: (r) => r.assessScore2024 || ''
    },
    {
      header: 'Subcategory Sign-Off?',
      width: 22,
      value: (r) => {
        const h = hmap.get(`${orgID}|${r.csF2SubcategoryID}`);
        return isCompleted(h) ? 'Yes' : 'No';
      }
    },
  ];

  downloadXlsx({
    rows,
    columns,
    fileName,
    sheetName: 'Attribute Mapping'
  });
}


--

// BEFORE
// const handleExport = () => displayRows?.length && exportRowsAsCsv(displayRows, 'csf-attribute-rows.csv');

// AFTER
import { exportAttributeRowsToXlsx } from '../utils/exportAttributeXlsx';

const handleExport = () => {
  if (!displayRows?.length) return;
  exportAttributeRowsToXlsx(displayRows, headers, activeOrgID, 'CSF-Attribute-Mapping.xlsx');
};

