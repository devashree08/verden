import os
import logging
from typing import Any, Dict, List, Optional
from contextlib import asynccontextmanager

from dotenv import load_dotenv
from fastapi import FastAPI, APIRouter, Request, Depends, Body, HTTPException
from fastapi.responses import JSONResponse
from fastapi.openapi.utils import get_openapi

from db import ODBCConnectionPool, exec_proc, POOL_SIZE
from contract import load_registry, build_param_contract, required_overrides_from_specs, validate_params, enrich_openapi

# ------------------------------------------------------------------------------
# Setup
# ------------------------------------------------------------------------------
load_dotenv()
logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger("api")

API_KEY = os.getenv("API_KEY", "super-secret-key")
REGISTRY_PATH = os.getenv("REGISTRY_PATH", "./procs.registry.json")

def require_api_key(request: Request):
    if request.headers.get("X-API-Key") != API_KEY:
        raise HTTPException(
            status_code=401,
            detail={"fault": {"faultstring": "Unauthorized", "detail": {"errorcode": "E_UNAUTHORIZED"}}},
        )

def error_response(status_code: int, faultstring: str, codes: str | List[str]) -> JSONResponse:
    detail = [{"errorcode": c} for c in codes] if isinstance(codes, list) else {"errorcode": codes}
    return JSONResponse(status_code=status_code, content={"fault": {"faultstring": faultstring, "detail": detail}})

# ------------------------------------------------------------------------------
# Lifespan (no deprecated on_event)
# ------------------------------------------------------------------------------
@asynccontextmanager
async def lifespan(app: FastAPI):
    app.state.pool = ODBCConnectionPool(size=POOL_SIZE)
    app.state.registry = load_registry(REGISTRY_PATH)
    register_from_registry(app)
    yield

app = FastAPI(
    title=os.getenv("API_TITLE", "ProcBridge API"),
    version=os.getenv("API_VERSION", "1.0.0"),
    description="Expose selected stored procedures as APIs. Contracts auto-generated from SQL metadata with tiny overrides.",
    lifespan=lifespan,
)

router = APIRouter()

# ------------------------------------------------------------------------------
# Dynamic routes
# ------------------------------------------------------------------------------
def register_from_registry(app: FastAPI):
    for ep in app.state.registry.get("endpoints", []):
        register_endpoint(app, ep)
    app.include_router(router)

def register_endpoint(app: FastAPI, ep: Dict[str, Any]):
    schema = ep["schema"]; proc = ep["proc"]; path = ep["path"]; method = ep["method"].upper()
    summary = ep.get("summary", f"Execute {schema}.{proc}")
    description = ep.get("description", "")

    async def handle_get(request: Request, _auth=Depends(require_api_key)):
        try:
            pool: ODBCConnectionPool = request.app.state.pool
            specs = build_param_contract(pool, schema, proc, "GET", ep.get("params"))
            # pull & validate query
            query = dict(request.query_params)
            errcodes = validate_params(specs, query, source="query")
            if errcodes:
                return error_response(400, "Bad Request", errcodes[:10])
            # build args dict only from declared query params
            args = {s["name"]: query.get(s["name"]) for s in specs if s["in"] == "query" and s["name"] in query}
            rows = exec_proc(pool, schema, proc, args, required_overrides=required_overrides_from_specs(specs))
            return {"rows": rows}
        except KeyError as k:
            return error_response(400, "Bad Request", f"E_MISSING_{str(k).strip('\"').upper()}")
        except Exception:
            logger.exception("GET exec failed for %s.%s", schema, proc)
            return error_response(500, "Server error", "E_SERVER")

    async def handle_post(payload: Dict[str, Any] = Body(...), request: Request = None, _auth=Depends(require_api_key)):
        try:
            if not isinstance(payload, dict):
                return error_response(400, "Bad Request", "E_BODY_NOT_OBJECT")
            pool: ODBCConnectionPool = request.app.state.pool
            specs = build_param_contract(pool, schema, proc, "POST", ep.get("params"))
            errcodes = validate_params(specs, payload, source="body")
            if errcodes:
                return error_response(400, "Bad Request", errcodes[:10])
            rows = exec_proc(pool, schema, proc, payload, required_overrides=required_overrides_from_specs(specs))
            return {"rows": rows}
        except KeyError as k:
            return error_response(400, "Bad Request", f"E_MISSING_{str(k).strip('\"').upper()}")
        except Exception:
            logger.exception("POST exec failed for %s.%s", schema, proc)
            return error_response(500, "Server error", "E_SERVER")

    if method == "GET":
        router.add_api_route(
            path, handle_get, methods=["GET"], name=f"{schema}.{proc}",
            summary=summary, description=description,
            responses={200: {"description":"OK"}, 400: {"description":"Bad Request"}, 401: {"description":"Unauthorized"}, 500: {"description":"Server Error"}},
        )
    elif method == "POST":
        router.add_api_route(
            path, handle_post, methods=["POST"], name=f"{schema}.{proc}",
            summary=summary, description=description,
            responses={200: {"description":"OK"}, 400: {"description":"Bad Request"}, 401: {"description":"Unauthorized"}, 500: {"description":"Server Error"}},
        )
    else:
        raise RuntimeError(f"Unsupported method '{method}'. Use GET or POST.")

# ------------------------------------------------------------------------------
# OpenAPI 3.1 with 42C error schema + auto params/requestBody + security
# ------------------------------------------------------------------------------
def custom_openapi():
    spec = get_openapi(
        title=app.title, version=app.version, description=app.description, routes=app.routes
    )
    # let contract builder enrich the spec based on SQL metadata + tiny overrides
    return enrich_openapi(spec, app.state.registry.get("endpoints", []), app.state.pool)

app.openapi = custom_openapi

# ------------------------------------------------------------------------------
# Local run helper
# ------------------------------------------------------------------------------
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=False)
