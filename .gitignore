using System.Security.Claims;
using Maturity.Portal.Authorization;

namespace Maturity.Portal.Extensions;

public static class ClaimsPrincipalExtensions
{
    public static string GetDisplayName(this ClaimsPrincipal u)
    {
        var first = u.FindFirst(PortalClaimTypes.GivenName)?.Value;
        var last  = u.FindFirst(PortalClaimTypes.Surname)?.Value;
        var name  = string.Join(' ', new[] { first, last }.Where(s => !string.IsNullOrWhiteSpace(s))).Trim();
        if (string.IsNullOrWhiteSpace(name))
            name = u.Identity?.Name ?? u.FindFirst(PortalClaimTypes.EID)?.Value ?? "unknown";
        name = new string(name.Where(ch => !char.IsControl(ch)).ToArray());
        return name.Length > 256 ? name[..256] : name;
    }
}



using Microsoft.AspNetCore.Authorization;
using Microsoft.Extensions.Options;
using Maturity.Portal.Authorization;
using Maturity.Portal.Configurations;
using Maturity.Portal.Services;

namespace Maturity.Portal.Extensions;

public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddPortalPolicyServices(this IServiceCollection services, IConfiguration config)
    {
        services.Configure<HeaderIdentityOptions>(config.GetSection("Auth:Headers"));
        services.Configure<PolicyCacheOptions>(config.GetSection("Auth:PolicyCache"));

        services.AddMemoryCache();
        services.AddSingleton(TimeProvider.System);

        services.AddScoped<IPortalPolicyService, PortalPolicyService>();
        services.AddScoped<IOrgPolicyResolver, DbOrgPolicyResolver>();

        services.AddAuthorization(options =>
        {
            options.FallbackPolicy = new AuthorizationPolicyBuilder()
                .RequireAuthenticatedUser()
                .Build();

            PortalCompositePolicies.Register(options);
        });

        services.AddSingleton<IAuthorizationPolicyProvider>(sp =>
        {
            var opts = sp.GetRequiredService<IOptions<AuthorizationOptions>>();
            var fallback = new DefaultAuthorizationPolicyProvider(opts);
            return new DynamicPolicyProvider(fallback);
        });

        return services;
    }
}





using Maturity.Portal.Middlewares;
using Microsoft.AspNetCore.Builder;

namespace Maturity.Portal.Extensions;

public static class ApplicationBuilderExtensions
{
    public static IApplicationBuilder UsePortalSsoIdentity(this IApplicationBuilder app)
        => app.UseMiddleware<SsoIdentityMiddleware>();

    public static IApplicationBuilder UsePortalCorrelationLogging(this IApplicationBuilder app)
        => app.UseMiddleware<CorrelationLoggingMiddleware>();
}





using Maturity.Portal.Configurations;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.HttpOverrides;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace Maturity.Portal.Extensions;

public static class SecureHeaderExtensions
{
    public static void AddSecureHeaders(this IServiceCollection services, IConfiguration config)
    {
        services.Configure<SecureHeaderOptions>(config.GetSection("Security:Headers"));
    }

    public static IApplicationBuilder UseSecureHeaders(this IApplicationBuilder app, IWebHostEnvironment env)
    {
        // Remove server header
        app.ApplicationServices.GetRequiredService<IServiceCollection>();
        // Kestrel's Server header can be disabled in Program via builder.WebHost.ConfigureKestrel(o => o.AddServerHeader = false);

        app.Use(async (ctx, next) =>
        {
            var resp = ctx.Response.Headers;

            // Minimal hardening set
            if (!resp.ContainsKey("X-Content-Type-Options")) resp.Append("X-Content-Type-Options", "nosniff");
            if (!resp.ContainsKey("X-Frame-Options"))        resp.Append("X-Frame-Options", "SAMEORIGIN");
            if (!resp.ContainsKey("Referrer-Policy"))        resp.Append("Referrer-Policy", "no-referrer");
            if (!resp.ContainsKey("X-Permitted-Cross-Domain-Policies")) resp.Append("X-Permitted-Cross-Domain-Policies", "none");
            if (!resp.ContainsKey("Permissions-Policy"))     resp.Append("Permissions-Policy", "geolocation=(), microphone=(), camera=()");

            await next();
        });

        // HSTS should be enabled only on HTTPS and non-dev
        if (!env.IsDevelopment())
        {
            app.UseHsts();
        }

        return app;
    }
}







using System.IO;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;
using Serilog;
using Serilog.Events;
using Serilog.Formatting.Json;
using Serilog.Filters;
using Maturity.Portal.Authorization;

namespace Maturity.Portal.Extensions;

public static class SerilogExtensions
{
    /// <summary>
    /// Bootstraps Serilog from configuration, with sensible fallbacks:
    /// - Reads "Serilog" section if present (preferred).
    /// - Else reads "PortalLogging:Directory" + "PortalLogging:MinimumLevel".
    /// - Writes pretty Console + JSON file logs.
    /// - Enrich: Environment, Application, CorrelationId/EID/UserName via LogContext.
    /// </summary>
    public static void UsePortalSerilog(this WebApplicationBuilder builder)
    {
        // Prefer full Serilog section if provided
        var hasSerilogSection = builder.Configuration.GetSection("Serilog").Exists();

        // Fallbacks
        var dir = builder.Configuration["PortalLogging:Directory"];
        if (string.IsNullOrWhiteSpace(dir))
            dir = Path.Combine(AppContext.BaseDirectory, "logs");

        Directory.CreateDirectory(dir);

        var minLevelStr = builder.Configuration["PortalLogging:MinimumLevel"] ?? "Information";
        var minLevel = ParseLevel(minLevelStr, LogEventLevel.Information);

        var appName = builder.Environment.ApplicationName ?? "Maturity.Portal";
        var envName = builder.Environment.EnvironmentName;

        var loggerCfg = new LoggerConfiguration()
            .Enrich.FromLogContext()
            .Enrich.WithProperty("application", appName)
            .Enrich.WithProperty("environment", envName)
            // If you want machine/IP add here, but avoid PII.
            .MinimumLevel.Is(minLevel)
            .MinimumLevel.Override("Microsoft", LogEventLevel.Warning)
            .MinimumLevel.Override("Microsoft.AspNetCore", LogEventLevel.Warning)
            .MinimumLevel.Override("System", LogEventLevel.Warning);

        // Console pretty output for local/deploy logs
        loggerCfg = loggerCfg.WriteTo.Console(
            outputTemplate:
                "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj} " +
                "(corr:{correlationId} eid:{eid} user:{userName}){NewLine}{Exception}");

        // JSON rolling file logs
        loggerCfg = loggerCfg.WriteTo.File(
            formatter: new JsonFormatter(renderMessage: true),
            path: Path.Combine(dir, "portal-log-.json"),
            rollingInterval: RollingInterval.Day,
            retainedFileCountLimit: 30,
            restrictedToMinimumLevel: minLevel,
            shared: true);

        // Filter out noisy health endpoints (optional)
        loggerCfg = loggerCfg.Filter.ByExcluding(Matching.WithProperty<string>("RequestPath", p =>
            p != null && (p.StartsWith("/health", StringComparison.OrdinalIgnoreCase))));

        if (hasSerilogSection)
        {
            // Allow overriding via Serilog config; our sinks above still apply unless overridden
            loggerCfg = loggerCfg.ReadFrom.Configuration(builder.Configuration);
        }

        Log.Logger = loggerCfg.CreateLogger();
        builder.Host.UseSerilog();
    }

    /// <summary>
    /// Adds Serilog request logging middleware with correlation enrichment.
    /// Place AFTER UsePortalCorrelationLogging() so LogContext has corr/eid/userName.
    /// </summary>
    public static void UsePortalRequestLogging(this IApplicationBuilder app)
    {
        app.UseSerilogRequestLogging(opts =>
        {
            opts.MessageTemplate = "HTTP {RequestMethod} {RequestPath} responded {StatusCode} in {Elapsed:0.0000} ms";
            // Attach a couple of handy values to each request log
            opts.EnrichDiagnosticContext = (diag, http) =>
            {
                var corr = http.Response.Headers["X-Correlation-ID"].ToString();
                if (string.IsNullOrWhiteSpace(corr)) corr = http.TraceIdentifier;
                diag.Set("correlationId", corr);

                var eid = http.User?.FindFirst(PortalClaimTypes.EID)?.Value;
                var user = http.User?.Identity?.Name;
                if (!string.IsNullOrWhiteSpace(eid))  diag.Set("eid", eid);
                if (!string.IsNullOrWhiteSpace(user)) diag.Set("userName", user);

                diag.Set("RequestPath", http.Request.Path.Value ?? string.Empty);
            };
        });
    }

    private static LogEventLevel ParseLevel(string s, LogEventLevel fallback)
        => Enum.TryParse<LogEventLevel>(s, true, out var lvl) ? lvl : fallback;
}
