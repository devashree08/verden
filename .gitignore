// src/pages/NarrativePage.jsx
import * as React from "react";
import { useMemo, useRef, useState, useEffect } from "react";
import {
  Box, Card, CardContent, Typography, Button, ButtonGroup, Stack, TextField, Switch,
  FormControlLabel, FormControl, InputLabel, Select, MenuItem, Chip, Tabs, Tab, Divider,
  Accordion, AccordionSummary, AccordionDetails, List, ListItemButton, ListItemText,
  IconButton, Avatar, LinearProgress, Paper, Collapse, Checkbox, ListItemIcon
} from "@mui/material";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import VisibilityIcon from "@mui/icons-material/Visibility";
import PictureAsPdfIcon from "@mui/icons-material/PictureAsPdf";
import DescriptionIcon from "@mui/icons-material/Description";
import PsychologyIcon from "@mui/icons-material/Psychology";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";
import TaskAltIcon from "@mui/icons-material/TaskAlt";
import AddLinkIcon from "@mui/icons-material/AddLink";
import EditIcon from "@mui/icons-material/Edit";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import CloseIcon from "@mui/icons-material/Close";
import SaveIcon from "@mui/icons-material/Save";
import AssignmentTurnedInIcon from "@mui/icons-material/AssignmentTurnedIn";
import FilterListIcon from "@mui/icons-material/FilterList";
import AssessmentIcon from "@mui/icons-material/Assessment";
import MenuOpenIcon from "@mui/icons-material/MenuOpen";
import MenuIcon from "@mui/icons-material/Menu";

import { NAVBAR_HEIGHT } from "../layouts/LayoutUIContext";

/* ------------------ CSF 2.0 realistic subset ------------------ */
const SUBCATS = [
  "GV.RR-01","PR.AA-01","PR.AT-01","PR.DS-01","PR.PS-01",
  "DE.AE-02","DE.AE-03","RS.MI-01","RC.RP-01","ID.IM-01"
];

const DEFINITIONS = {
  "GV.RR-01":"Organizational leadership is responsible and accountable for cybersecurity risk and fosters a risk-aware, ethical, continually improving culture.",
  "PR.AA-01":"Identities and credentials for authorized users, services, and hardware are managed by the organization.",
  "PR.AT-01":"Personnel receive awareness and training to perform general tasks with cyber risks in mind.",
  "PR.DS-01":"Data-at-rest is protected (confidentiality, integrity, availability).",
  "PR.PS-01":"Configuration management practices are established and applied.",
  "DE.AE-02":"Potentially adverse events are analyzed to better understand associated activities.",
  "DE.AE-03":"Information is correlated from multiple sources.",
  "RS.MI-01":"Incidents are contained.",
  "RC.RP-01":"Recovery portion of the incident response plan is executed once initiated from the incident response process.",
  "ID.IM-01":"Improvements are identified from evaluations."
};

const ORG_COLORS = {
  VCS: "#0052cc",
  "VGS-T": "#7c4dff",
  Network: "#f5b700",   // changed to yellow
  TPD: "#e67e22",
};
const getOrgColor = (org) => ORG_COLORS[org] || "#1976d2";

const makeArtifacts = (count, sc, lvl) =>
  Array.from({ length: count }, (_, i) => ({
    id: `${sc}-${lvl}-A${i + 1}`,
    title: `Artifact ${i + 1} for ${sc}`,
    url: `https://example.com/artifacts/${encodeURIComponent(sc)}/${lvl}/${i + 1}`,
  }));

const MATURITY = {};
SUBCATS.forEach((sc) => {
  MATURITY[sc] = {
    L3: [
      { id: `${sc}-L3-1`, title: "Attribute 1", definition: `${DEFINITIONS[sc]} (baseline L3).`, artifacts: makeArtifacts(2, sc, "L3") },
      { id: `${sc}-L3-2`, title: "Attribute 2", definition: `Documented process, periodic review, and stakeholder visibility for ${sc}.`, artifacts: makeArtifacts(2, sc, "L3") },
    ],
    L4: [
      { id: `${sc}-L4-1`, title: "Attribute 1", definition: `Metrics-driven continuous improvement & automation for ${sc}.`, artifacts: makeArtifacts(3, sc, "L4") },
      { id: `${sc}-L4-2`, title: "Attribute 2", definition: `Proactive validation and governance for ${sc}.`, artifacts: makeArtifacts(2, sc, "L4") },
      { id: `${sc}-L4-3`, title: "Attribute 3", definition: `Integrated with enterprise risk metrics & assurance for ${sc}.`, artifacts: makeArtifacts(2, sc, "L4") },
    ],
  };
});

const DB = { orgs: ["VCS", "VGS-T", "Network", "TPD"], subcategories: SUBCATS, maturity: MATURITY };

/* Directory for filters + owner/custodian */
const DIRECTORY = SUBCATS.reduce((acc, sc, i) => {
  acc[sc] = {
    function: ["Cyber","Technology","Network","Product"][i%4],
    category: sc.split(".")[0],
    owner: ["Nancy Schueller","Nirvana Smith","Jason Herden","Felicia R. Sosa"][i%4],
    custodian: ["Arun Iyer","Priya Shah","Zoe Kim","Luis Ortega"][i%4],
  };
  return acc;
}, {});

/* --------- MultiSelect with checkbox list (like your screenshot) ---------- */
const MENU_PROPS = {
  PaperProps: { style: { maxHeight: 360 } },
};

function MultiCheckboxSelect({ label, options, value, onChange, renderOption }) {
  const allSelectedLabels = value;
  return (
    <FormControl fullWidth size="small">
      <InputLabel id={`${label}-label`}>{label}</InputLabel>
      <Select
        labelId={`${label}-label`}
        multiple
        value={value}
        onChange={(e) => onChange(e.target.value)}
        label={label}
        MenuProps={MENU_PROPS}
        renderValue={(sel) => (
          <Box sx={{ display: "flex", flexWrap: "wrap", gap: 0.5 }}>
            {sel.map((v) => (
              <Chip key={v} label={renderOption ? renderOption(v) : v} size="small" />
            ))}
          </Box>
        )}
      >
        {options.map((opt) => {
          const labelText = renderOption ? renderOption(opt) : opt;
          const checked = allSelectedLabels.indexOf(opt) > -1;
          return (
            <MenuItem key={opt} value={opt}>
              <ListItemIcon>
                <Checkbox size="small" checked={checked} />
              </ListItemIcon>
              <ListItemText primary={labelText} />
            </MenuItem>
          );
        })}
      </Select>
    </FormControl>
  );
}

/* ------------------ Mock Agent (replace with real API) ------------------ */
async function callAgentAPI({ agent, prompt, target, userComment }) {
  await new Promise((r) => setTimeout(r, 600));
  const score = Math.round(72 + Math.random() * 24);
  const context = userComment ? `\n(User commentary included.)` : "";
  const text =
    target?.type === "attribute"
      ? `Attribute Assessor for ${target.subcat} ${target.level} • ${target.title}:${context}\n- Align artifacts to acceptance criteria.\n- Add evidence of periodic review.\n- Note exceptions and compensating controls.\n- Map gaps to L4 transition plan.`
      : `Narrative Assessor:\n• Strengths: L3→L4 roadmap, KPI cadence.\n• Gaps: missing Tier-2 evidence in PR.DS-01.\n• Risks: legacy platform dependencies.\n• Actions: prioritize IAM hardening; formalize artifact reviews.`;
  return { agent, score, text, usage: { tokens: 580, ms: 600 } };
}

/* ------------------ Attribute block ------------------ */
function AttributeBlock({
  sc, level, attr,
  userComment, onChangeUserComment,
  aiComment, onChangeAiComment,
  artifacts, onAddArtifact, onAskAI,
  aiBtn, actBtn
}) {
  const [adding, setAdding] = useState(false);
  const [newTitle, setNewTitle] = useState("");
  const [newUrl, setNewUrl] = useState("");
  const [commentTab, setCommentTab] = useState(0); // 0 = User, 1 = AI Notes

  return (
    <Accordion disableGutters>
      <AccordionSummary expandIcon={<ExpandMoreIcon />} sx={{ px: 1 }}>
        <Box sx={{ pr: 1 }}>
          <Typography fontWeight={700} variant="subtitle1">{attr.title}</Typography>
          <Typography variant="caption" color="text.secondary">{attr.definition}</Typography>
        </Box>
      </AccordionSummary>
      <AccordionDetails>
        <Stack spacing={1.5}>
          <Stack direction="row" spacing={1} justifyContent="flex-end" flexWrap="wrap">
            <Button
              size="small"
              startIcon={<PsychologyIcon />}
              onClick={() =>
                onAskAI({ type: "attribute", subcat: sc, level, attributeId: attr.id, title: attr.title })
              }
              {...aiBtn}
            >
              AI Assist
            </Button>
            <Button size="small" startIcon={<EditIcon />} {...actBtn}>Edit</Button>
          </Stack>

          {/* Artifacts */}
          <Box>
            <Typography variant="subtitle2" sx={{ mb: 0.5 }}>Artifacts</Typography>
            <List dense>
              {artifacts.map((a) => (
                <ListItemButton key={a.id} component="a" href={a.url} target="_blank">
                  <ListItemText primary={a.title} secondary={a.url} />
                </ListItemButton>
              ))}
            </List>
            {adding ? (
              <Stack direction={{ xs: "column", sm: "row" }} spacing={1} sx={{ mt: 1 }}>
                <TextField size="small" label="Title" value={newTitle} onChange={(e) => setNewTitle(e.target.value)} />
                <TextField size="small" label="URL" value={newUrl} onChange={(e) => setNewUrl(e.target.value)} />
                <Button size="small" startIcon={<AddLinkIcon />} {...actBtn} onClick={() => {
                  if (newTitle && newUrl) { onAddArtifact({ title: newTitle, url: newUrl }); setNewTitle(""); setNewUrl(""); setAdding(false); }
                }}>Add</Button>
                <IconButton size="small" onClick={() => setAdding(false)}><CloseIcon fontSize="inherit" /></IconButton>
              </Stack>
            ) : (
              <Button size="small" startIcon={<AddLinkIcon />} onClick={() => setAdding(true)} sx={{ mt: 0.5 }} {...actBtn}>
                Add Artifact
              </Button>
            )}
          </Box>

          {/* Commentary tabs */}
          <Box>
            <Tabs value={commentTab} onChange={(_, v) => setCommentTab(v)}>
              <Tab label="User Commentary" />
              <Tab label="AI Notes" />
            </Tabs>
            <Box sx={{ mt: 1 }}>
              {commentTab === 0 ? (
                <TextField
                  label="User Commentary"
                  fullWidth size="small" multiline minRows={4}
                  value={userComment || ""} onChange={(e) => onChangeUserComment(e.target.value)}
                />
              ) : (
                <TextField
                  label="AI Notes"
                  fullWidth size="small" multiline minRows={4}
                  value={aiComment || ""} onChange={(e) => onChangeAiComment(e.target.value)}
                />
              )}
            </Box>
          </Box>
        </Stack>
      </AccordionDetails>
    </Accordion>
  );
}

/* =============================== MAIN =============================== */
export default function NarrativePage() {
  /* Narrative state */
  const [org, setOrg] = useState("VCS");
  const [subcats, setSubcats] = useState(["GV.RR-01", "DE.AE-02", "DE.AE-03"]);
  const [execSum, setExecSum] = useState("");
  const [scope, setScope] = useState("");
  const [quant, setQuant] = useState(false);
  const [coverage, setCoverage] = useState("");
  const [pct, setPct] = useState(85);
  const [levelTab, setLevelTab] = useState("L3");

  /* Per-subcategory Tracfone Integration text */
  const [tracfone, setTracfone] = useState({});

  /* Commentary and artifacts */
  const [userComments, setUserComments] = useState({});
  const [aiComments, setAiComments] = useState({});
  const [artifactMap, setArtifactMap] = useState(() => {
    const init = {};
    DB.subcategories.forEach((sc) => ["L3","L4"].forEach((lvl) => {
      MATURITY[sc][lvl].forEach((a) => { init[`${sc}|${lvl}|${a.id}`] = a.artifacts; });
    }));
    return init;
  });

  /* Saved drafts + filters */
  const [filtersOpen, setFiltersOpen] = useState(true);
  const [drafts, setDrafts] = useState([]);
  const [filters, setFilters] = useState({
    function: [], category: [], subcat: [], owner: [], custodian: [], status: [], org: []
  });

  /* AI panel */
  const [aiVisible, setAiVisible] = useState(true);
  const [aiAgent, setAiAgent] = useState("Narrative Coach");
  const [aiBusy, setAiBusy] = useState(false);
  const [aiTab, setAiTab] = useState(0); // 0 AI Result, 1 Assessor, 2 History (new order)
  const [history, setHistory] = useState([]);
  const [assessorText, setAssessorText] = useState("");
  const [aiResult, setAiResult] = useState(null);

  /* Saved rail toggle */
  const [savedOpen, setSavedOpen] = useState(true);

  /* Split-resize (viewport-aware init) */
  const [panePct, setPanePct] = useState(() => {
    const saved = localStorage.getItem("ngPanePct_v3");
    if (saved) return Number(saved);
    const w = window.innerWidth;
    if (w >= 1600) return 62;
    if (w >= 1280) return 60;
    if (w >= 1024) return 58;
    return 100;
  });
  const containerRef = useRef(null);
  const startDrag = (e) => {
    if (!containerRef.current) return;
    const startX = e.clientX;
    const rect = containerRef.current.getBoundingClientRect();
    const start = panePct;
    const move = (ev) => {
      const pct = Math.min(75, Math.max(35, start + ((ev.clientX - startX) / rect.width) * 100));
      setPanePct(pct);
    };
    const up = () => {
      window.removeEventListener("mousemove", move);
      window.removeEventListener("mouseup", up);
      localStorage.setItem("ngPanePct_v3", String(panePct));
    };
    window.addEventListener("mousemove", move);
    window.addEventListener("mouseup", up);
  };
  const hasUserSetSplit = useRef(!!localStorage.getItem("ngPanePct_v3"));
  useEffect(() => {
    if (hasUserSetSplit.current) return;
    const onResize = () => {
      if (hasUserSetSplit.current) return;
      const w = window.innerWidth;
      const next = w >= 1600 ? 62 : w >= 1280 ? 60 : w >= 1024 ? 58 : 100;
      setPanePct(next);
    };
    window.addEventListener("resize", onResize);
    return () => window.removeEventListener("resize", onResize);
  }, []);
  useEffect(() => {
    if (localStorage.getItem("ngPanePct_v3")) hasUserSetSplit.current = true;
  }, [panePct]);

  /* Narrative string for export */
  const narrative = useMemo(() => {
    const lines = [];
    lines.push(`# Narrative for ${org}`);
    // Subcategory info first: Owners/Custodians for selected subcats
    if (subcats.length) {
      lines.push("", "**Subcategory Info**");
      subcats.forEach(sc => {
        lines.push(`- ${sc}: Owners: ${DIRECTORY[sc].owner} • Custodians: ${DIRECTORY[sc].custodian}`);
      });
    }
    if (execSum) lines.push("", `**Executive Summary**\n${execSum}`);
    if (scope) lines.push("", `**Scope**\n${scope}`);
    // Tracfone Integration after Scope
    const tfNotes = subcats.map(sc => tracfone[sc] && `• ${sc}: ${tracfone[sc]}`).filter(Boolean).join("\n");
    if (tfNotes) lines.push("", `**Tracfone Integration**\n${tfNotes}`);
    if (quant) lines.push("", `**Coverage / Profile (Quantitative)**\nAssessed population coverage: ~${pct}%.`);
    else if (coverage) lines.push("", `**Coverage / Profile (Qualitative)**\n${coverage}`);
    lines.push("");
    subcats.forEach((sc) => {
      lines.push(`## ${sc}: ${DEFINITIONS[sc]}`);
      ["L3","L4"].forEach((lvl) => {
        lines.push(`**Maturity ${lvl.replace("L","Level ")}:**`);
        MATURITY[sc][lvl].forEach((a) => {
          const key = `${sc}|${lvl}|${a.id}`;
          const arts = (artifactMap[key] || []).map((x) => x.title).join(", ");
          lines.push(`- *${a.title}:* ${a.definition}`);
          if (userComments[key]) lines.push(`  - **User Commentary:** ${userComments[key]}`);
          if (aiComments[key]) lines.push(`  - **AI Notes:** ${aiComments[key]}`);
          lines.push(`  - **Artifacts:** ${arts}`);
        });
        lines.push("");
      });
    });
    return lines.join("\n");
  }, [org, subcats, execSum, scope, tracfone, quant, coverage, pct, userComments, aiComments, artifactMap]);

  /* Styles */
  const aiBtn = { sx: { bgcolor: "#111", color: "#fff", "&:hover": { bgcolor: "#000" } } };
  const primaryAct = { sx: { bgcolor: "#001C4D", color: "#fff", "&:hover": { bgcolor: "#001540" } } };
  const neutralAct = { sx: { bgcolor: "#3C4858", color: "#fff", "&:hover": { bgcolor: "#2E3744" } } };

  /* Export helpers */
  async function exportPDF() {
    const { jsPDF } = await import("jspdf");
    const doc = new jsPDF({ unit: "pt", format: "a4" });
    const margin = 40, maxWidth = 515;
    const lines = doc.splitTextToSize(narrative.replaceAll("\n","\n\n"), maxWidth);
    doc.text(lines, margin, margin);
    doc.save(`Narrative_${org}.pdf`);
  }
  async function exportDocx() {
    const docx = await import("docx");
    const { Document, Packer, Paragraph, TextRun, HeadingLevel } = docx;
    const blocks = [ new Paragraph({ heading: HeadingLevel.TITLE, children: [new TextRun(`Narrative for ${org}`)] }) ];
    narrative.split("\n").forEach((line) => {
      if (!line.trim()) { blocks.push(new Paragraph("")); return; }
      if (line.startsWith("## ")) blocks.push(new Paragraph({ heading: HeadingLevel.HEADING_2, children: [new TextRun(line.replace("## ",""))] }));
      else if (line.startsWith("**") && line.endsWith("**")) blocks.push(new Paragraph({ heading: HeadingLevel.HEADING_3, children: [new TextRun(line.replaceAll("**",""))] }));
      else blocks.push(new Paragraph({ children: [new TextRun(line.replaceAll("**",""))] }));
    });
    const doc = new Document({ sections: [{ children: blocks }] });
    const blob = await Packer.toBlob(doc);
    const url = URL.createObjectURL(blob); const a = document.createElement("a");
    a.href = url; a.download = `Narrative_${org}.docx`; a.click(); URL.revokeObjectURL(url);
  }

  /* AI actions (attribute-focused) */
  const runAttributeAI = async ({ subcat, level, attributeId, title }) => {
    setAiAgent("Attribute Assessor");
    setAiTab(0); // AI Result first
    const key = `${subcat}|${level}|${attributeId}`;
    setAiBusy(true);
    const res = await callAgentAPI({
      agent: "Attribute Assessor",
      prompt: `Assess ${subcat} ${level}: ${title}`,
      target: { type: "attribute", subcat, level, attributeId, title },
      userComment: userComments[key],
    });
    setAiBusy(false);
    // Fill AI Notes on that attribute
    setAiComments((m) => ({ ...m, [key]: (m[key] ? m[key] + "\n\n" : "") + res.text }));
    setAiResult({ text: res.text, score: res.score, agent: res.agent, target: { subcat, level, attributeId, title } });
    setHistory((h) => [...h, { id: crypto.randomUUID(), type: "suggestion", agent: res.agent, score: res.score, target: { type:"attribute", subcat, level, attributeId, title }, text: res.text, ts: new Date().toISOString() }]);
  };
  const runAssessor = async () => {
    setAiAgent("Narrative Coach");
    setAiTab(1);
    setAiBusy(true);
    const res = await callAgentAPI({ agent: "Narrative Assessor", prompt: "Assess narrative", target: { type: "narrative" }});
    setAssessorText(`Confidence ${res.score}%\n\n${res.text}`);
    setAiBusy(false);
  };
  const applyFromHistory = (entry) => {
    if (entry?.target?.type !== "attribute") return;
    const { subcat, level, attributeId } = entry.target;
    const key = `${subcat}|${level}|${attributeId}`;
    setAiComments((m) => ({ ...m, [key]: (m[key] ? m[key] + "\n\n" : "") + entry.text }));
    setHistory((h) => [...h, { ...entry, id: crypto.randomUUID(), type: "applied", ts: new Date().toISOString() }]);
  };
  const clearHistory = () => setHistory([]);

  /* Save/Load */
  const saveDraft = (complete = false) => {
    const entry = {
      id: crypto.randomUUID(),
      org,
      subcats: [...subcats],
      complete,
      narrative,
      meta: { execSum, scope, quant, coverage, pct, levelTab, tracfone },
      userComments, aiComments, artifacts: artifactMap,
      updatedAt: new Date().toISOString(),
    };
    setDrafts((d) => [entry, ...d]);
  };
  const filteredDrafts = drafts.filter((d) => {
    const f = filters;
    if (f.org.length && !f.org.includes(d.org)) return false;
    if (f.status.length) {
      const wantC = f.status.includes("Complete");
      const wantI = f.status.includes("Incomplete");
      if (!((wantC && d.complete) || (wantI && !d.complete))) return false;
    }
    if (f.subcat.length && !d.subcats.some((s) => f.subcat.includes(s))) return false;
    if (f.category.length && !d.subcats.some((s) => f.category.includes(s.split(".")[0]))) return false;
    if (f.function.length && !d.subcats.some((s) => f.function.includes(DIRECTORY[s].function))) return false;
    if (f.owner.length && !d.subcats.some((s) => f.owner.includes(DIRECTORY[s].owner))) return false;
    if (f.custodian.length && !d.subcats.some((s) => f.custodian.includes(DIRECTORY[s].custodian))) return false;
    return true;
  });

  /* ---------- UI blocks ---------- */
  const ActionBar = (
    <Card variant="outlined" sx={{ position: "sticky", top: NAVBAR_HEIGHT + 8, zIndex: (t) => t.zIndex.appBar - 1, mb: 2 }}>
      <CardContent sx={{ py: 1.25 }}>
        <Stack direction="row" alignItems="center" spacing={1} flexWrap="wrap">
          <Typography variant="h6" sx={{ flexGrow: 1 }}>CSF 2.0 Narrative</Typography>
          <Chip label={org} sx={{ bgcolor: getOrgColor(org), color: "#fff" }} />
          <Button startIcon={<VisibilityIcon />} variant="outlined" sx={{ borderColor: "#001C4D", color: "#001C4D" }}>Preview</Button>
          <Button startIcon={<PictureAsPdfIcon />} onClick={exportPDF} {...primaryAct}>PDF</Button>
          <Button startIcon={<DescriptionIcon />} onClick={exportDocx} {...primaryAct}>DOCX</Button>
          <Button startIcon={<AssessmentIcon />} onClick={runAssessor} {...aiBtn}>GenAI Narrative Assessor</Button>
          <Divider orientation="vertical" flexItem sx={{ mx: 0.5 }} />
          <Button startIcon={<SaveIcon />} onClick={() => saveDraft(false)} {...neutralAct}>Save</Button>
          <Button startIcon={<AssignmentTurnedInIcon />} onClick={() => saveDraft(true)} {...neutralAct}>Mark Complete</Button>
          <Button startIcon={<FilterListIcon />} onClick={() => setFiltersOpen((v)=>!v)} {...neutralAct}>
            {filtersOpen ? "Hide Filters" : "Show Filters"}
          </Button>
          <Button
            startIcon={savedOpen ? <MenuOpenIcon/> : <MenuIcon/>}
            onClick={() => setSavedOpen(v => !v)}
            {...neutralAct}
          >
            {savedOpen ? "Hide Saved" : "Show Saved"}
          </Button>
          {!aiVisible && (
            <Button onClick={() => setAiVisible(true)} {...aiBtn}>Show AI</Button>
          )}
        </Stack>
      </CardContent>
    </Card>
  );

  const FiltersBar = (
    <Card variant="outlined" sx={{ mb: 2 }}>
      <CardContent>
        <Stack direction="row" alignItems="center" justifyContent="space-between">
          <Typography variant="subtitle1">Filters</Typography>
          <Button size="small" onClick={() => setFiltersOpen((v)=>!v)} {...neutralAct}>
            {filtersOpen ? "Collapse" : "Expand"}
          </Button>
        </Stack>
        <Collapse in={filtersOpen} timeout="auto" unmountOnExit>
          <Stack spacing={2} sx={{ mt: 1 }}>
            <Stack direction={{ xs:"column", md:"row" }} spacing={2}>
              <MultiCheckboxSelect label="Org" options={DB.orgs} value={filters.org} onChange={(v)=>setFilters(f=>({...f,org:v}))} />
              <MultiCheckboxSelect
                label="Function"
                options={[...new Set(SUBCATS.map((s)=>DIRECTORY[s].function))]}
                value={filters.function}
                onChange={(v)=>setFilters(f=>({...f,function:v}))}
              />
              <MultiCheckboxSelect
                label="Categories"
                options={[...new Set(SUBCATS.map((s)=>s.split(".")[0]))]}
                value={filters.category}
                onChange={(v)=>setFilters(f=>({...f,category:v}))}
              />
            </Stack>
            <Stack direction={{ xs:"column", md:"row" }} spacing={2}>
              <MultiCheckboxSelect label="Subcategories" options={SUBCATS} value={filters.subcat} onChange={(v)=>setFilters(f=>({...f,subcat:v}))} />
              <MultiCheckboxSelect
                label="SubcatOwner"
                options={[...new Set(SUBCATS.map((s)=>DIRECTORY[s].owner))]}
                value={filters.owner}
                onChange={(v)=>setFilters(f=>({...f,owner:v}))}
              />
              <MultiCheckboxSelect
                label="SubcatCustodian"
                options={[...new Set(SUBCATS.map((s)=>DIRECTORY[s].custodian))]}
                value={filters.custodian}
                onChange={(v)=>setFilters(f=>({...f,custodian:v}))}
              />
              <MultiCheckboxSelect label="Status" options={["Complete","Incomplete"]} value={filters.status} onChange={(v)=>setFilters(f=>({...f,status:v}))} />
            </Stack>
          </Stack>
        </Collapse>
      </CardContent>
    </Card>
  );

  const RightPane = (
    <Card variant="outlined" sx={{ height: 1 }}>
      <CardContent sx={{ display:"flex", flexDirection:"column", gap:1, height:1 }}>
        <Stack direction="row" spacing={1} alignItems="center">
          <Avatar sx={{ bgcolor: getOrgColor(org) }}><PsychologyIcon/></Avatar>
          <Box>
            <Typography variant="h6">AI Assist</Typography>
            <Typography variant="caption" color="text.secondary">AI Result · Assessor · History</Typography>
          </Box>
          <Box sx={{ flex:1 }}/>
          <Button size="small" variant="text" onClick={()=>setAiVisible(false)} sx={{ color:"#111" }}>Hide</Button>
        </Stack>

        <FormControl fullWidth size="small">
          <InputLabel id="agent-label">Agent</InputLabel>
          <Select labelId="agent-label" value={aiAgent} label="Agent" onChange={(e)=>setAiAgent(e.target.value)}>
            <MenuItem value="Narrative Coach">Narrative Coach</MenuItem>
            <MenuItem value="Attribute Assessor">Attribute Assessor</MenuItem>
          </Select>
        </FormControl>

        {/* Tabs: AI Result, Assessor, History */}
        <Tabs value={aiTab} onChange={(_,v)=>setAiTab(v)}>
          <Tab label="AI Result" />
          <Tab label="Assessor" />
          <Tab label="History" />
        </Tabs>

        {/* AI RESULT */}
        {aiTab === 0 && (
          <Paper variant="outlined" sx={{ p:1, flex:1, overflow:"auto", minHeight:260 }}>
            {aiBusy && <><Typography variant="body2">Thinking…</Typography><LinearProgress sx={{ my:1 }}/></>}
            {!aiBusy && (aiResult ? (
              <Stack spacing={1}>
                <Stack direction="row" spacing={1} alignItems="center">
                  <Chip size="small" label={`Agent: ${aiResult.agent}`} />
                  <Chip size="small" label={`Confidence ${aiResult.score}%`}
                    color={aiResult.score>=85?"success":aiResult.score>=75?"warning":"default"} />
                </Stack>
                <Typography variant="body2" color="text.secondary">
                  Target: {aiResult.target?.subcat} {aiResult.target?.level} • {aiResult.target?.title}
                </Typography>
                <Typography sx={{ whiteSpace:"pre-wrap" }}>{aiResult.text}</Typography>
              </Stack>
            ) : (
              <Typography variant="body2" color="text.secondary">
                Trigger this by clicking “AI Assist” on an attribute.
              </Typography>
            ))}
          </Paper>
        )}

        {/* ASSESSOR */}
        {aiTab === 1 && (
          <Paper variant="outlined" sx={{ p:1, flex:1, overflow:"auto", minHeight:260 }}>
            {assessorText
              ? <Typography sx={{ whiteSpace:"pre-wrap" }}>{assessorText}</Typography>
              : (
                <Stack alignItems="flex-start" spacing={1}>
                  <Typography variant="body2" color="text.secondary">
                    Run the GenAI Narrative Assessor from the Action Bar to populate this view.
                  </Typography>
                  <Button startIcon={<AssessmentIcon/>} onClick={runAssessor} {...aiBtn}>
                    Run Assessor
                  </Button>
                </Stack>
              )}
          </Paper>
        )}

        {/* HISTORY */}
        {aiTab === 2 && (
          <Paper variant="outlined" sx={{ p:1, flex:1, overflow:"auto", minHeight:260 }}>
            <Stack direction="row" justifyContent="space-between" alignItems="center" sx={{ mb:1 }}>
              <Typography variant="subtitle2">History</Typography>
              <Button startIcon={<ClearAllIcon/>} onClick={clearHistory} {...aiBtn}>Clear</Button>
            </Stack>
            <Stack spacing={1}>
              {history.length===0 && <Typography variant="body2" color="text.secondary">No history yet.</Typography>}
              {history.map((h)=>(
                <Box key={h.id}>
                  <Stack direction="row" spacing={1} alignItems="center" sx={{ mb:0.5 }}>
                    <Chip size="small" label={h.type==="applied"?"Applied":"Suggestion"} color={h.type==="applied"?"success":"default"} />
                    <Chip size="small" label={`Confidence ${h.score??0}%`} color={h.score>=85?"success":h.score>=75?"warning":"default"} />
                    <Typography variant="caption" color="text.secondary">{new Date(h.ts||Date.now()).toLocaleString()}</Typography>
                  </Stack>
                  <Typography variant="body2" sx={{ whiteSpace:"pre-wrap" }}>{h.text}</Typography>
                  {h.type==="suggestion" && h.target?.type==="attribute" && (
                    <Stack direction="row" spacing={1} sx={{ mt:0.5 }} useFlexGap flexWrap="wrap">
                      <Button size="small" startIcon={<TaskAltIcon fontSize="inherit" />} onClick={()=>applyFromHistory(h)} {...aiBtn}>
                        Apply to Attribute AI Notes
                      </Button>
                      <IconButton size="small" title="Copy" onClick={()=>navigator.clipboard.writeText(h.text)}>
                        <ContentCopyIcon fontSize="inherit" />
                      </IconButton>
                    </Stack>
                  )}
                  <Divider sx={{ my:1 }}/>
                </Box>
              ))}
            </Stack>
          </Paper>
        )}
      </CardContent>
    </Card>
  );

  /* ------------------ Render ------------------ */
  return (
    <Box sx={{ px:{ xs:2, md:3 }, py:{ xs:2, md:3 } }}>
      {ActionBar}
      {FiltersBar}

      {/* Split panes */}
      <Box
        ref={containerRef}
        sx={{
          display:{ xs:"block", md:"grid" },
          gridTemplateColumns: aiVisible ? { md: `${panePct}% 6px ${100 - panePct}%` } : { md: "100%" },
          columnGap:0,
          height:{ md:`calc(100vh - ${NAVBAR_HEIGHT + 160}px)` },
          minHeight:480,
        }}
      >
        {/* LEFT column */}
        <Box sx={{ overflowY:{ md:"auto" } }}>
          <Box
            sx={{
              display:{ xs:"block", md:"grid" },
              gridTemplateColumns:{ md: `${savedOpen ? "280px" : "0px"}  ${savedOpen ? "16px" : "0px"} 1fr` },
              columnGap:{ md:0 },
              pr:{ md:1 },
              transition: "grid-template-columns 200ms ease",
            }}
          >
            {/* Saved rail (toggle) */}
            <Box sx={{ display: savedOpen ? "block" : "none", position:{ md:"sticky" }, top:{ md:0 }, alignSelf:"start" }}>
              <Card variant="outlined" sx={{ mb:2 }}>
                <CardContent>
                  <Typography variant="subtitle1">Saved Narratives</Typography>
                  <Divider sx={{ my:1 }}/>
                  <List dense sx={{ maxHeight:420, overflowY:"auto" }}>
                    {filteredDrafts.length===0 && <ListItemText primary="No saved narratives match filters." />}
                    {filteredDrafts.map((d)=>(
                      <ListItemButton key={d.id} onClick={()=> {
                        setOrg(d.org); setSubcats(d.subcats);
                        setExecSum(d.meta.execSum); setScope(d.meta.scope);
                        setQuant(d.meta.quant); setCoverage(d.meta.coverage);
                        setPct(d.meta.pct); setLevelTab(d.meta.levelTab);
                        setTracfone(d.meta.tracfone || {});
                        setUserComments(d.userComments || {}); setAiComments(d.aiComments || {});
                        setArtifactMap(d.artifacts);
                      }}>
                        <ListItemText primary={`${d.org} • ${d.complete?"Complete":"Draft"}`} secondary={d.subcats.join(", ")} />
                      </ListItemButton>
                    ))}
                  </List>
                </CardContent>
              </Card>
            </Box>

            {/* spacer */}
            <Box sx={{ display: { xs:"none", md: savedOpen ? "block" : "none" } }} />

            {/* Narrative content */}
            <Box>
              <Card variant="outlined" sx={{ mb:2 }}>
                <CardContent>
                  <Stack spacing={2}>
                    {/* Organization */}
                    <Box>
                      <Typography variant="subtitle2" sx={{ mb:0.5 }}>Organization</Typography>
                      <ButtonGroup fullWidth>
                        {DB.orgs.map((o)=>(
                          <Button
                            key={o}
                            variant={org===o?"contained":"outlined"}
                            onClick={()=>setOrg(o)}
                            sx={{
                              bgcolor: org===o ? getOrgColor(o) : undefined,
                              color:   org===o ? "#fff" : undefined,
                              "&:hover": org===o ? { bgcolor: getOrgColor(o) } : undefined,
                            }}
                          >{o}</Button>
                        ))}
                      </ButtonGroup>
                    </Box>

                    {/* Subcategories (checkbox style) */}
                    <MultiCheckboxSelect
                      label="Subcategories"
                      options={DB.subcategories}
                      value={subcats}
                      onChange={setSubcats}
                      renderOption={(sc) => `${sc}`}
                    />

                    {/* Subcategory Info (Owners/Custodians) BEFORE Exec Summary */}
                    {subcats.length > 0 && (
                      <Card variant="outlined" sx={{ bgcolor:"background.default" }}>
                        <CardContent sx={{ py:1.5 }}>
                          <Typography variant="subtitle2" sx={{ mb:1 }}>Subcategory Info</Typography>
                          <Stack spacing={0.75}>
                            {subcats.map(sc=>(
                              <Box key={sc}>
                                <Typography variant="body2" fontWeight={700}>{sc}</Typography>
                                <Typography variant="body2" color="text.secondary">
                                  Owners: <strong>{DIRECTORY[sc].owner}</strong> • Custodians: <strong>{DIRECTORY[sc].custodian}</strong>
                                </Typography>
                              </Box>
                            ))}
                          </Stack>
                        </CardContent>
                      </Card>
                    )}

                    {/* Executive Summary */}
                    <Stack spacing={1}>
                      <Stack direction="row" alignItems="center" justifyContent="space-between">
                        <Typography variant="subtitle2">Executive Summary</Typography>
                        <Button
                          size="small"
                          onClick={()=>{ /* Phase 1 focuses on attribute AI; keeping entry point to open AI pane */ setAiTab(1); setAiAgent("Narrative Coach"); }}
                          sx={{ bgcolor:"#111", color:"#fff", "&:hover":{ bgcolor:"#000" } }}
                        >
                          Enrich with AI
                        </Button>
                      </Stack>
                      <TextField value={execSum} onChange={(e)=>setExecSum(e.target.value)} multiline minRows={3} fullWidth placeholder="Exec summary…" />
                    </Stack>

                    {/* Scope (manual) */}
                    <Stack spacing={1}>
                      <Typography variant="subtitle2">Scope</Typography>
                      <TextField value={scope} onChange={(e)=>setScope(e.target.value)} multiline minRows={2} fullWidth placeholder="Scope…" />
                    </Stack>

                    {/* Tracfone Integration AFTER scope */}
                    <Card variant="outlined">
                      <CardContent sx={{ py:1.5 }}>
                        <Typography variant="subtitle2" sx={{ mb:1 }}>Tracfone Integration</Typography>
                        <Stack spacing={1}>
                          {subcats.map(sc=>(
                            <TextField
                              key={sc}
                              size="small"
                              label={`${sc} — Tracfone note`}
                              multiline minRows={2} fullWidth
                              value={tracfone[sc] || ""}
                              onChange={(e)=>setTracfone(m=>({ ...m, [sc]: e.target.value }))}
                            />
                          ))}
                        </Stack>
                      </CardContent>
                    </Card>

                    {/* Coverage */}
                    <Box>
                      <FormControlLabel control={<Switch checked={quant} onChange={(e)=>setQuant(e.target.checked)} />} label={quant ? "Quantitative" : "Qualitative"} />
                      {!quant ? (
                        <TextField value={coverage} onChange={(e)=>setCoverage(e.target.value)} fullWidth placeholder="Qualitative coverage…" />
                      ) : (
                        <TextField label="Coverage %" type="number" inputProps={{ min:0, max:100 }} value={pct} onChange={(e)=>setPct(Number(e.target.value))} sx={{ width:160 }} />
                      )}
                    </Box>
                  </Stack>
                </CardContent>
              </Card>

              {/* Attributes block */}
              <Card variant="outlined">
                <CardContent>
                  <Tabs value={levelTab} onChange={(_,v)=>setLevelTab(v)} variant="scrollable">
                    <Tab label="Level 3" value="L3" />
                    <Tab label="Level 4" value="L4" />
                  </Tabs>
                  <Divider sx={{ my:1 }} />
                  <Stack spacing={1.5}>
                    {subcats.map((sc)=>(
                      <Box key={sc}>
                        {/* slimmer header */}
                        <Typography variant="subtitle1" fontWeight={800}>{sc}</Typography>
                        <Typography variant="body2" color="text.secondary" sx={{ mb:1 }}>
                          {DEFINITIONS[sc]}
                        </Typography>

                        <Stack spacing={1}>
                          {MATURITY[sc][levelTab].map((attr)=>{
                            const key = `${sc}|${levelTab}|${attr.id}`;
                            return (
                              <AttributeBlock
                                key={key}
                                sc={sc} level={levelTab} attr={attr}
                                userComment={userComments[key]}
                                onChangeUserComment={(val)=>setUserComments(c=>({...c,[key]:val}))}
                                aiComment={aiComments[key]}
                                onChangeAiComment={(val)=>setAiComments(c=>({...c,[key]:val}))}
                                artifacts={artifactMap[key] || []}
                                onAddArtifact={(item)=>setArtifactMap(m=>({ ...m, [key]: [...(m[key]||[]), { id: crypto.randomUUID(), ...item }] }))}
                                onAskAI={(target)=>runAttributeAI(target)}
                                aiBtn={aiBtn} actBtn={neutralAct}
                              />
                            );
                          })}
                        </Stack>
                      </Box>
                    ))}
                  </Stack>
                </CardContent>
              </Card>
            </Box>
          </Box>
        </Box>

        {/* Resizer */}
        {aiVisible && (
          <Box role="separator" aria-label="Resize panes" onMouseDown={startDrag}
            sx={{ display:{ xs:"none", md:"block" }, cursor:"col-resize", bgcolor:"divider", "&:hover":{ bgcolor:"text.primary" }, width:6 }}
          />
        )}

        {/* RIGHT: AI Assist */}
        {aiVisible && <Box sx={{ overflowY:{ md:"auto" }, height:1 }}>{RightPane}</Box>}
      </Box>
    </Box>
  );
}
