// src/features/attributeMapping/utils/exportAttributeMappingExcel.js
import { exportExcel } from '../../../ui/data/ExcelExport';
import { fetchAttributeFeed } from '../api/attributeApi';
import { normalizeHeaders, normalizeRows } from '../utils/normalizeFeed';
import { buildSheetsForAttributeMapping } from './attributeWorkbook';
import { bulkArtifactsForExport } from '../api/artifactsApi';

/**
 * exportAttributeMappingExcel({ filters, selectedSubcatID, fileName })
 * - If selectedSubcatID is present -> export just that subcat scope
 * - Else, export all subcats under current filters
 */
export async function exportAttributeMappingExcel({ filters, selectedSubcatID, fileName }) {
  // 1) pull headers for the current filters (finalOnly=false so we get everything)
  const headerResp = await fetchAttributeFeed({
    functionIds:    filters.functionIds,
    categoryIds:    filters.categoryIds,
    subcatIds:      filters.subcatIds,
    ownerNames:     filters.ownerNames,
    custodianNames: filters.custodianNames,
    maturity:       filters.maturity,
    finalOnly:      false,
    search:         filters.search,
  });
  const headers = normalizeHeaders(headerResp.headers || []);

  // Subcategory scope for rows + artifacts
  let subcatIdsWanted = [];
  if (selectedSubcatID) {
    subcatIdsWanted = [selectedSubcatID];
  } else if (filters.subcatIds?.length) {
    subcatIdsWanted = filters.subcatIds;
  } else {
    const set = new Set(headers.map(h => String(h.csF2SubcategoryID)));
    subcatIdsWanted = Array.from(set);
  }

  // 2) pull rows for those subcats
  const rowsResp = await fetchAttributeFeed({
    functionIds:    filters.functionIds,
    categoryIds:    filters.categoryIds,
    subcatIds:      subcatIdsWanted,
    ownerNames:     filters.ownerNames,
    custodianNames: filters.custodianNames,
    maturity:       filters.maturity,
    finalOnly:      false,
    search:         filters.search,
  });
  const rows = normalizeRows(rowsResp.rows || []);

  // 3) bulk artifacts for the export scope (deriving orgIDs and subcatIDs from headers)
  const orgIDs = Array.from(new Set(headers.map(h => h.orgID))).filter(Boolean);
  const csf2SubcategoryIDs = subcatIdsWanted;

  const bulk = await bulkArtifactsForExport({
    orgIDs,
    csf2SubcategoryIDs,
  });

  // 4) index artifacts by the same composite identity we use for rows
  const makeKey = ({ orgID, csF2SubcategoryID, maturityLevel, csF1SubcategoryID, attributeNum, customAttributeNum }) => {
    const org = String(orgID ?? '0');
    const sub = String(csF2SubcategoryID ?? '0');
    const ml  = String(maturityLevel ?? '0');
    // custom → C|0|customNum; baseline → B|csf1|attrNum
    if (customAttributeNum != null) {
      return `${org}|${sub}|${ml}|C|0|${String(customAttributeNum ?? '0')}`;
    }
    return `${org}|${sub}|${ml}|B|${String(csF1SubcategoryID ?? '0')}|${String(attributeNum ?? '0')}`;
  };

  const artifactByKey = new Map(
    (bulk || []).map(r => [ makeKey({
      orgID: r.orgID,
      csF2SubcategoryID: r.csF2SubcategoryID,
      maturityLevel: r.maturityLevel,
      csF1SubcategoryID: r.csf1SubcategoryID,
      attributeNum: r.attributeNum,
      customAttributeNum: r.customAttributeNum
    }), r.artifacts || '' ])
  );

  // 5) build sheets and export (Final View still applied inside workbook builder)
  const sheets = buildSheetsForAttributeMapping({
    headers,
    rows,
    finalOnly: !!filters.finalOnly,
    artifacts: artifactByKey,     // <-- new
  });

  await exportExcel({
    fileName: fileName || `CSF-Attribute-Mapping ${new Date().toISOString().slice(0,10)}.xlsx`,
    sheets,
  });
}
