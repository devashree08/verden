import * as React from "react";
import { useMemo, useRef, useState } from "react";
import {
  ThemeProvider,
  createTheme,
  CssBaseline,
  Container,
  Grid,
  Card,
  CardContent,
  Typography,
  Button,
  ButtonGroup,
  Box,
  Chip,
  TextField,
  Switch,
  FormControlLabel,
  Select,
  MenuItem,
  InputLabel,
  FormControl,
  Tabs,
  Tab,
  Divider,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Drawer,
  List,
  ListItemButton,
  ListItemText,
  Stack,
  Tooltip,
  Link,
  Snackbar,
  Alert
} from "@mui/material";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import SaveIcon from "@mui/icons-material/Save";
import VisibilityIcon from "@mui/icons-material/Visibility";
import PictureAsPdfIcon from "@mui/icons-material/PictureAsPdf";
import DescriptionIcon from "@mui/icons-material/Description";

// ---------- THEME (blue primary buttons) ----------
const theme = createTheme({
  palette: {
    mode: "light",
    primary: { main: "#1976d2" }, // MUI blue
  },
  shape: { borderRadius: 12 },
  typography: { fontSize: 14 },
});

// ---------- CSF 2.0 TEST DATA (grounded to csf.tools) ----------
// Sources:
// GV.RR-01: Organizational leadership accountable for cybersecurity risk.
// PR.AA-01: Identities and credentials are managed.
// PR.AT-01: Personnel receive awareness & training (general).
// PR.DS-01: Data-at-rest protected.
// PR.PS-01: Configuration management practices established.
// DE.AE-02: Potentially adverse events are analyzed.
// DE.AE-03: Information is correlated from multiple sources.
// RS.MI-01: Incidents are contained.
// RC.RP-01: Recovery plan portion executed.
// ID.IM-01: Improvements identified from evaluations.

const SUBCATS = [
  "GV.RR-01",
  "PR.AA-01",
  "PR.AT-01",
  "PR.DS-01",
  "PR.PS-01",
  "DE.AE-02",
  "DE.AE-03",
  "RS.MI-01",
  "RC.RP-01",
  "ID.IM-01",
];

const definitions = {
  "GV.RR-01": "Organizational leadership is responsible and accountable for cybersecurity risk and fosters a risk-aware, ethical, continually improving culture.",
  "PR.AA-01": "Identities and credentials for authorized users, services, and hardware are managed by the organization.",
  "PR.AT-01": "Personnel are provided with awareness and training to perform general tasks with cybersecurity risks in mind.",
  "PR.DS-01": "The confidentiality, integrity, and availability of data-at-rest are protected.",
  "PR.PS-01": "Configuration management practices are established and applied.",
  "DE.AE-02": "Potentially adverse events are analyzed to better understand associated activities.",
  "DE.AE-03": "Information is correlated from multiple sources.",
  "RS.MI-01": "Incidents are contained.",
  "RC.RP-01": "The recovery portion of the incident response plan is executed once initiated from the incident response process.",
  "ID.IM-01": "Improvements are identified from evaluations.",
};

const makeArtifacts = (count, sc, lvl) =>
  Array.from({ length: count }, (_, i) => ({
    id: `${sc}-${lvl}-A${i + 1}`,
    title: `Artifact ${i + 1} for ${sc}`,
    url: `https://example.com/artifacts/${encodeURIComponent(sc)}/${lvl}/${i + 1}`,
  }));

const fakeDB = { orgs: ["VCS", "TPD", "NETWORK"], subcategories: SUBCATS, maturity: {} };
SUBCATS.forEach((sc) => {
  fakeDB.maturity[sc] = {
    L3: [
      {
        id: `${sc}-L3-1`,
        title: `Attribute 1`,
        definition: `${definitions[sc]} (baseline practice at Level 3).`,
        artifacts: makeArtifacts(2, sc, "L3"),
      },
      {
        id: `${sc}-L3-2`,
        title: `Attribute 2`,
        definition: `Documented process, periodic review, and stakeholder visibility for ${sc}.`,
        artifacts: makeArtifacts(2, sc, "L3"),
      },
    ],
    L4: [
      {
        id: `${sc}-L4-1`,
        title: `Attribute 1`,
        definition: `Metrics-driven continuous improvement and automation for ${sc}.`,
        artifacts: makeArtifacts(3, sc, "L4"),
      },
      {
        id: `${sc}-L4-2`,
        title: `Attribute 2`,
        definition: `Proactive validation and governance for ${sc}.`,
        artifacts: makeArtifacts(2, sc, "L4"),
      },
      {
        id: `${sc}-L4-3`,
        title: `Attribute 3`,
        definition: `Integration with enterprise risk metrics and assurance for ${sc}.`,
        artifacts: makeArtifacts(2, sc, "L4"),
      },
    ],
  };
});

// ---------- SMALL HELPERS ----------
function MultiSelect({ label, options, selected, onChange }) {
  return (
    <FormControl fullWidth size="small">
      <InputLabel id={`${label}-label`}>{label}</InputLabel>
      <Select
        labelId={`${label}-label`}
        multiple
        value={selected}
        onChange={(e) => onChange(e.target.value)}
        inputProps={{ "aria-label": label }}
        label={label}
        renderValue={(sel) => (
          <Box sx={{ display: "flex", flexWrap: "wrap", gap: 0.5 }}>
            {sel.map((v) => (
              <Chip key={v} label={v} size="small" />
            ))}
          </Box>
        )}
      >
        {options.map((opt) => (
          <MenuItem key={opt} value={opt}>
            {opt}
          </MenuItem>
        ))}
      </Select>
    </FormControl>
  );
}

function AttributeBlock({ attr, value, onChange }) {
  return (
    <Accordion disableGutters sx={{ borderRadius: 2, overflow: "hidden" }}>
      <AccordionSummary expandIcon={<ExpandMoreIcon />}>
        <Stack spacing={0.5}>
          <Typography fontWeight={600}>{attr.title}</Typography>
          <Typography variant="body2" color="text.secondary">
            {attr.definition}
          </Typography>
        </Stack>
      </AccordionSummary>
      <AccordionDetails>
        <Stack spacing={2}>
          <Box>
            <Typography variant="subtitle2">Artifacts</Typography>
            <List dense>
              {attr.artifacts.map((a) => (
                <ListItemButton key={a.id} component="a" href={a.url} target="_blank">
                  <ListItemText primary={a.title} secondary={a.url} />
                </ListItemButton>
              ))}
            </List>
          </Box>
          <TextField
            label="User comment"
            placeholder="Add context for assessorâ€¦"
            fullWidth
            size="small"
            multiline
            minRows={3}
            value={value || ""}
            onChange={(e) => onChange(e.target.value)}
          />
        </Stack>
      </AccordionDetails>
    </Accordion>
  );
}

export default function App() {
  const [org, setOrg] = useState("VCS");
  const [subcats, setSubcats] = useState(["GV.RR-01", "DE.AE-02", "DE.AE-03"]);
  const [execSum, setExecSum] = useState(
    "We operate a central catalog of training aligned to cybersecurity roles. Updates published quarterly. Workday transition refined delivery without reducing quality."
  );
  const [scope, setScope] = useState(
    "This assessment covers VCS, Network, and TPD units and shared corporate functions."
  );
  const [quant, setQuant] = useState(false);
  const [coverage, setCoverage] = useState("Coverage sampled via interviews and artifact review.");
  const [pct, setPct] = useState(85);
  const [comments, setComments] = useState({});
  const [tab, setTab] = useState("L3");
  const [saved, setSaved] = useState([]);
  const [previewOpen, setPreviewOpen] = useState(false);
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [snack, setSnack] = useState("");
  const printableRef = useRef(null);

  const narrative = useMemo(() => {
    const lines = [];
    lines.push(`# Narrative for ${org}`);
    lines.push("");
    lines.push(`**Executive Summary**
${execSum}`);
    lines.push("");
    lines.push(`**Scope**
${scope}`);
    lines.push("");
    if (quant) lines.push(`**Coverage / Profile (Quantitative)**
Assessed population coverage: ~${pct}%.`);
    else lines.push(`**Coverage / Profile (Qualitative)**
${coverage}`);
    lines.push("");
    subcats.forEach((sc) => {
      lines.push(`## Subcategory ${sc}`);
      ["L3", "L4"].forEach((lvl) => {
        lines.push(`**Maturity ${lvl.replace("L", "Level ")}:**`);
        fakeDB.maturity[sc][lvl].forEach((a) => {
          const key = `${sc}|${lvl}|${a.id}`;
          lines.push(`- *${a.title}:* ${a.definition}`);
          if (comments[key]) lines.push(`  - **Comment:** ${comments[key]}`);
          const arts = a.artifacts.map((x) => x.title).join(", ");
          lines.push(`  - **Artifacts:** ${arts}`);
        });
        lines.push("");
      });
    });
    return lines.join("
");
  }, [org, subcats, execSum, scope, quant, coverage, pct, comments]);

  const saveNarrative = () => {
    const entry = {
      id: Date.now(),
      org,
      subcats: [...subcats],
      narrative,
      meta: { execSum, scope, quant, coverage, pct },
      comments,
    };
    setSaved((s) => [entry, ...s]);
    setSnack("Saved draft");
  };

  const loadNarrative = (n) => {
    setOrg(n.org);
    setSubcats(n.subcats);
    setExecSum(n.meta.execSum);
    setScope(n.meta.scope);
    setQuant(n.meta.quant);
    setCoverage(n.meta.coverage);
    setPct(n.meta.pct);
    setComments(n.comments || {});
    setDrawerOpen(false);
    setSnack("Loaded draft");
  };

  async function exportPDF() {
    try {
      const { jsPDF } = await import("jspdf");
      const doc = new jsPDF({ unit: "pt", format: "a4" });
      const margin = 40;
      const maxWidth = 515;
      const text = narrative.replaceAll("
", "

");
      const lines = doc.splitTextToSize(text, maxWidth);
      doc.text(lines, margin, margin);
      doc.save(`Narrative_${org}.pdf`);
    } catch (e) {
      setSnack("PDF export failed");
    }
  }

  async function exportDocx() {
    try {
      const docx = await import("docx");
      const { Document, Packer, Paragraph, TextRun, HeadingLevel } = docx;
      const blocks = [];
      blocks.push(new Paragraph({ heading: HeadingLevel.TITLE, children: [new TextRun(`Narrative for ${org}`)] }));
      narrative.split("
").forEach((line) => {
        if (!line.trim()) { blocks.push(new Paragraph("")); return; }
        if (line.startsWith("## ")) {
          blocks.push(new Paragraph({ heading: HeadingLevel.HEADING_2, children: [new TextRun(line.replace("## ", ""))] }));
        } else if (line.startsWith("**") && line.endsWith("**")) {
          blocks.push(new Paragraph({ heading: HeadingLevel.HEADING_3, children: [new TextRun(line.replaceAll("**", ""))] }));
        } else {
          blocks.push(new Paragraph({ children: [new TextRun(line.replaceAll("**", ""))] }));
        }
      });
      const doc = new Document({ sections: [{ children: blocks }] });
      const blob = await Packer.toBlob(doc);
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `Narrative_${org}.docx`;
      a.click();
      URL.revokeObjectURL(url);
    } catch (e) {
      setSnack("DOCX export failed");
    }
  }

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Box sx={{ bgcolor: "background.default", minHeight: "100dvh", py: 3 }}>
        <Container maxWidth="lg">
          <Typography variant="h4" fontWeight={700} gutterBottom>
            CSF 2.0 Narrative Generator (MUI / JSX)
          </Typography>

          <Grid container spacing={3}>
            {/* Left column */}
            <Grid item xs={12} md={4}>
              <Card>
                <CardContent>
                  <Stack spacing={2}>
                    <Box>
                      <Typography variant="subtitle2" sx={{ mb: 1 }}>Organization</Typography>
                      <ButtonGroup fullWidth>
                        {fakeDB.orgs.map((o) => (
                          <Button key={o} variant={org === o ? "contained" : "outlined"} onClick={() => setOrg(o)}>
                            {o}
                          </Button>
                        ))}
                      </ButtonGroup>
                    </Box>

                    <MultiSelect
                      label="Subcategories in scope"
                      options={fakeDB.subcategories}
                      selected={subcats}
                      onChange={setSubcats}
                    />

                    <TextField
                      label="Executive Summary"
                      value={execSum}
                      onChange={(e) => setExecSum(e.target.value)}
                      multiline
                      minRows={4}
                      fullWidth
                    />

                    <TextField
                      label="Scope"
                      value={scope}
                      onChange={(e) => setScope(e.target.value)}
                      multiline
                      minRows={3}
                      fullWidth
                    />

                    <Box>
                      <Stack direction="row" alignItems="center" justifyContent="space-between">
                        <Typography variant="subtitle2">Coverage / Profile</Typography>
                        <FormControlLabel
                          control={<Switch checked={quant} onChange={(e) => setQuant(e.target.checked)} />}
                          label={quant ? "Quantitative" : "Qualitative"}
                          componentsProps={{ typography: { variant: "body2" } }}
                        />
                      </Stack>
                      {!quant ? (
                        <TextField
                          value={coverage}
                          onChange={(e) => setCoverage(e.target.value)}
                          fullWidth
                          size="small"
                          multiline
                          minRows={3}
                        />
                      ) : (
                        <TextField
                          label="Coverage %"
                          type="number"
                          size="small"
                          inputProps={{ min: 0, max: 100 }}
                          value={pct}
                          onChange={(e) => setPct(Number(e.target.value))}
                          sx={{ mt: 1, maxWidth: 160 }}
                        />
                      )}
                    </Box>

                    <Divider />

                    <Stack direction="row" spacing={1} useFlexGap flexWrap="wrap">
                      <Button startIcon={<SaveIcon />} onClick={saveNarrative}>
                        Save
                      </Button>
                      <Button startIcon={<VisibilityIcon />} color="secondary" variant="outlined" onClick={() => setPreviewOpen(true)}>
                        Preview
                      </Button>
                      <Tooltip title="Export to PDF">
                        <Button startIcon={<PictureAsPdfIcon />} variant="outlined" onClick={exportPDF}>
                          PDF
                        </Button>
                      </Tooltip>
                      <Tooltip title="Export to Word (.docx)">
                        <Button startIcon={<DescriptionIcon />} variant="outlined" onClick={exportDocx}>
                          DOCX
                        </Button>
                      </Tooltip>
                      <Button variant="text" onClick={() => setDrawerOpen(true)}>Edit existing narrativeâ€¦</Button>
                    </Stack>
                  </Stack>
                </CardContent>
              </Card>
            </Grid>

            {/* Right column */}
            <Grid item xs={12} md={8}>
              <Card>
                <CardContent>
                  <Tabs value={tab} onChange={(_, v) => setTab(v)} aria-label="maturity tabs">
                    <Tab label="Maturity Level 3" value="L3" />
                    <Tab label="Maturity Level 4" value="L4" />
                  </Tabs>

                  <Divider sx={{ my: 2 }} />

                  <Stack spacing={3}>
                    {subcats.map((sc) => (
                      <Box key={sc}>
                        <Typography variant="h6" sx={{ mb: 1 }}>
                          {sc}: {definitions[sc]}
                        </Typography>
                        <Stack spacing={1.5}>
                          {fakeDB.maturity[sc][tab].map((attr) => {
                            const key = `${sc}|${tab}|${attr.id}`;
                            return (
                              <AttributeBlock
                                key={key}
                                attr={attr}
                                value={comments[key]}
                                onChange={(v) => setComments((c) => ({ ...c, [key]: v }))}
                              />
                            );
                          })}
                        </Stack>
                      </Box>
                    ))}
                  </Stack>
                </CardContent>
              </Card>
            </Grid>
          </Grid>

          {/* Hidden printable for fallback */}
          <Box ref={printableRef} sx={{ display: "none" }} aria-hidden>
            <pre>{narrative}</pre>
          </Box>
        </Container>

        {/* Preview Dialog */}
        <Dialog open={previewOpen} onClose={() => setPreviewOpen(false)} fullWidth maxWidth="md">
          <DialogTitle>Narrative Preview</DialogTitle>
          <DialogContent dividers>
            <Box sx={{ typography: "body1" }}>
              {narrative.split("
").map((line, i) => (
                <Typography key={i} sx={{
                  fontWeight: line.startsWith("**") ? 600 : undefined,
                  fontSize: line.startsWith("## ") ? 18 : undefined,
                }}>
                  {line.replaceAll("**", "").replace("## ", "")}
                </Typography>
              ))}
            </Box>
          </DialogContent>
          <DialogActions>
            <Button color="secondary" variant="outlined" onClick={() => setPreviewOpen(false)}>Close</Button>
            <Button startIcon={<PictureAsPdfIcon />} onClick={exportPDF}>Export PDF</Button>
            <Button startIcon={<DescriptionIcon />} variant="outlined" onClick={exportDocx}>Export DOCX</Button>
          </DialogActions>
        </Dialog>

        {/* Drawer: saved narratives */}
        <Drawer anchor="left" open={drawerOpen} onClose={() => setDrawerOpen(false)}>
          <Box sx={{ width: 360 }} role="presentation">
            <Typography variant="h6" sx={{ p: 2 }}>Saved narratives</Typography>
            <Divider />
            <List>
              {saved.length === 0 && (
                <ListItemText primary="Nothing saved yet." sx={{ p: 2 }} />
              )}
              {saved.map((n) => (
                <ListItemButton key={n.id} onClick={() => loadNarrative(n)}>
                  <ListItemText
                    primary={`${n.org}`}
                    secondary={<>
                      <Typography variant="caption" color="text.secondary">{n.subcats.join(', ')}</Typography>
                    </>}
                  />
                </ListItemButton>
              ))}
            </List>
          </Box>
        </Drawer>

        <Snackbar
          open={!!snack}
          autoHideDuration={2500}
          onClose={() => setSnack("")}
          anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
        >
          <Alert onClose={() => setSnack("")} severity="success" variant="filled">{snack}</Alert>
        </Snackbar>

        <Box sx={{ textAlign: "center", mt: 4 }}>
          <Typography variant="caption" color="text.secondary">
            Preview uses CSF 2.0 subcategories sourced from csf.tools. Buttons use MUI primary blue.
          </Typography>
        </Box>
      </Box>
    </ThemeProvider>
  );
}
