#!/usr/bin/env python3
"""
Hydrate descriptions in server/resources/fields/allapps_score.yaml using dbo.Risk_Element.

- Matches Risk_Element.elementName to YAML column names using a canonical key:
  lowercased, non-alphanumeric stripped (drops spaces, '/', '_', etc.)
  e.g., "SPI/PII Application" -> "spipiiapplication", "OCI Servers" -> "ociservers"

- Replaces column 'description' with cleaned 'scoreMessage' where matched,
  and sets description_auto: true.

Dry-run is default (no file writes). Use --write to persist changes.

Examples:
  uv run python -m scripts.hydrate_score_descriptions --preview 10
  uv run python -m scripts.hydrate_score_descriptions --write --preview 25 --show-unmatched 30
"""

from __future__ import annotations

# Ensure project root importability
from pathlib import Path
import sys
PROJECT_ROOT = Path(__file__).resolve().parents[1]
if str(PROJECT_ROOT) not in sys.path:
    sys.path.insert(0, str(PROJECT_ROOT))

import argparse
import contextlib
import html
import logging
import re
from typing import Any, Dict, List, Tuple

import pyodbc
from ruamel.yaml import YAML

from framework.core.config import (
    SQLSERVER_HOST,
    SQLSERVER_PORT,
    SQLSERVER_DATABASE,
    SQLSERVER_USERNAME,
    SQLSERVER_PASSWORD,
    ALLOW_INSECURE_SQL_ENCRYPTION,
)

# -------- YAML config (round-trip; stable indent) --------
yaml = YAML(typ="rt")
yaml.preserve_quotes = True
yaml.width = 4096
yaml.indent(mapping=2, sequence=4, offset=2)

log = logging.getLogger("hydrate_score_descriptions")

# -------- SQL connection helpers --------
_CONNECT_TIMEOUT = 10


def _conn_str() -> str:
    enc = "no" if ALLOW_INSECURE_SQL_ENCRYPTION else "yes"
    trust = "yes" if ALLOW_INSECURE_SQL_ENCRYPTION else "no"
    return (
        f"Driver={{ODBC Driver 18 for SQL Server}};"
        f"Server=tcp:{SQLSERVER_HOST},{SQLSERVER_PORT};"
        f"Database={SQLSERVER_DATABASE};"
        f"Uid={SQLSERVER_USERNAME};"
        f"Pwd={SQLSERVER_PASSWORD};"
        f"Encrypt={enc};"
        f"TrustServerCertificate={trust};"
        f"Connection Timeout={_CONNECT_TIMEOUT};"
    )


@contextlib.contextmanager
def _connect():
    cn = pyodbc.connect(_conn_str())
    try:
        yield cn
    finally:
        with contextlib.suppress(Exception):
            cn.close()


# -------- Canonicalization / cleaning --------
_CANON = re.compile(r"[^a-z0-9]+")


def _canon(s: str) -> str:
    return _CANON.sub("", s.lower())


def _strip_html(s: str) -> str:
    # remove simple <p>..</p> and other tags, unescape entities
    s = re.sub(r"</?p[^>]*>", " ", s, flags=re.IGNORECASE)
    s = re.sub(r"<[^>]+>", " ", s)
    s = html.unescape(s)
    return " ".join(s.split()).strip()


# -------- YAML I/O --------
def _yaml_path() -> Path:
    return PROJECT_ROOT / "server" / "resources" / "fields" / "allapps_score.yaml"


def _load_yaml(path: Path) -> Dict[str, Any]:
    if not path.exists():
        raise FileNotFoundError(f"YAML not found: {path}")
    with path.open("r", encoding="utf-8") as f:
        return yaml.load(f) or {}


def _save_yaml(path: Path, data: Dict[str, Any]) -> None:
    with path.open("w", encoding="utf-8") as f:
        yaml.dump(data, f)


# -------- DB fetch --------
def _fetch_risk_elements(cn) -> List[Tuple[str, str]]:
    cur = cn.cursor()
    cur.execute("SELECT elementName, scoreMessage FROM dbo.Risk_Element")
    out: List[Tuple[str, str]] = []
    for name, msg in cur.fetchall():
        if not name or not msg:
            continue
        out.append((str(name), str(msg)))
    return out


def main():
    ap = argparse.ArgumentParser(description="Hydrate score YAML descriptions from dbo.Risk_Element.")
    ap.add_argument("--write", action="store_true", help="Persist changes; otherwise dry-run.")
    ap.add_argument("--preview", type=int, default=20, help="Show first N updated columns in the summary.")
    ap.add_argument("--show-unmatched", type=int, default=20, help="List first N unmatched YAML columns in summary.")
    args = ap.parse_args()

    logging.basicConfig(level=logging.INFO, format="%(levelname)s %(message)s")

    # Load YAML
    yaml_path = _yaml_path()
    data = _load_yaml(yaml_path)
    cols = data.get("columns") or []
    if not cols:
        log.error("No 'columns' array in %s. Run gen_field_dicts.py first.", yaml_path)
        sys.exit(2)

    # Canon map of YAML columns -> reference to the actual column dict
    yaml_by_key: Dict[str, Dict[str, Any]] = {}
    for col in cols:
        name = str(col.get("name", "")).strip()
        if not name:
            continue
        yaml_by_key[_canon(name)] = col

    # Pull risk elements
    updates: List[Tuple[str, str]] = []
    matched_keys: set[str] = set()
    risk_keys: set[str] = set()

    with _connect() as cn:
        for elem_name, score_msg in _fetch_risk_elements(cn):
            key = _canon(elem_name)
            if not key:
                continue
            risk_keys.add(key)
            col = yaml_by_key.get(key)
            if not col:
                continue
            cleaned = _strip_html(score_msg)
            if not cleaned:
                continue
            old_desc = str(col.get("description") or "")
            if old_desc != cleaned:
                col["description"] = cleaned
                col["description_auto"] = True
                updates.append((col.get("name", elem_name), cleaned))
            matched_keys.add(key)

    # Compute unmatched YAML columns (i.e., no risk element match)
    yaml_keys = set(yaml_by_key.keys())
    unmatched_keys = sorted(yaml_keys - matched_keys)

    # Build friendly names for unmatched report
    unmatched_names = [yaml_by_key[k].get("name", k) for k in unmatched_keys]

    # Summary
    if args.write:
        _save_yaml(yaml_path, data)
        print(f"[write]   Updated {len(updates)} column descriptions in {yaml_path}")
    else:
        print(f"[dry-run] Would update {len(updates)} column descriptions in {yaml_path}")

    # Show sample of updated
    if updates:
        print(f"  updated (showing up to {args.preview}):")
        for i, (name, desc) in enumerate(updates[: max(1, args.preview)]):
            print(f"    - {name}: {desc[:120]}{'â€¦' if len(desc) > 120 else ''}")

    # Show unmatched info
    print(f"  unmatched columns: {len(unmatched_names)} (no Risk_Element match)")
    if unmatched_names:
        print(f"  unmatched sample (up to {args.show_unmatched}):")
        for nm in unmatched_names[: max(1, args.show_unmatched)]:
            print(f"    - {nm}")


if __name__ == "__main__":
    main()
