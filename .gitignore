1) What you’ve built (in plain English)

You have one codebase that exposes selected SQL Server stored procedures in two ways:

REST API (FastAPI) for humans/services:

Swagger /docs for dev testing.

A strong OpenAPI contract suitable for 42Crunch security audits.

API-key auth and strict request schemas.

MCP Server for AI agents/tools:

An MCP client (e.g., an IDE or agent runtime) can discover “tools” automatically.

Each tool maps to one stored procedure with a strict argument schema.

Same validation and DB execution logic as REST—just a different transport.

Both paths share the same registry, same parameter and result schema logic, and same DB execution layer. You define which procs are exposed (and on which paths/methods) in procs.registry.json.

2) The three core Python modules (and what each does)
A) db.py – database utilities

Loads connection settings from .env.

Creates a tiny ODBC connection pool.

Provides:

get_proc_parameters(...) to discover proc parameters from sys.parameters.

exec_proc(...) to execute a proc with a list of values in ordinal order.

describe_first_result_set(...) which uses sys.dm_exec_describe_first_result_set_for_object to fetch the column contract of the proc’s first result set (names, SQL types, nullability, lengths) without executing it.

Why this matters: You get a machine-readable schema of the result set directly from SQL Server—no guessing, no sampling rows.

B) contract.py – schema/contract builder

Reads procs.registry.json.

Converts SQL param metadata → OpenAPI/JSON-Schema parameter definitions:

type (string/integer/number/boolean)

format (e.g., int32, int64, double, date, date-time)

maxLength for varchar/nvarchar/char/nchar (using correct char count for NVARCHAR)

pattern (strict regexes; no .* wildcards; CSV patterns for Ids style params; ISO patterns for date/time)

required (from SQL default/nullability or your override)

Builds response models for 200 responses using describe_first_result_set(...):

Generates a named model per endpoint (e.g., GetAppsByUserModel).

The model is an envelope { rows: [...] } with:

additionalProperties: false at the envelope level (so only rows).

rows.items is an object per row with:

One property per discovered column (keeps exact column names).

Each property has type, format (if applicable), pattern, maxLength (strings), and nullable.

required: [...] lists non-nullable columns.

additionalProperties: true at the row level (so a new DB column doesn’t break your clients).

Enriches the OpenAPI:

Sets OpenAPI 3.1.

Adds global apiKey security scheme and applies it.

Adds your ErrorResponse component and wires it into 400/401/403/404/(415 for POST)/500.

Injects the 200 response as a $ref to the named model (so consumers see a real DTO contract, not inline JSON).

For POST, builds strict requestBody with additionalProperties: false.

Why this matters: You get a 42Crunch-friendly, tight spec for requests, and a clear contract for responses that still tolerates new DB columns (future-proofing).

C) main.py – REST API

Uses FastAPI lifespan (modern) to:

Initialize the DB pool.

Load the registry.

Programmatically register routes from the registry.

For each endpoint:

Registers a route on the exact path with the chosen method (GET or POST).

Uses API-Key auth (X-API-Key).

Validates params against the same schemas the OpenAPI advertises (regex, lengths, required).

Calls exec_proc(...) and returns { "rows": [...] }.

Errors return your 42Crunch ErrorResponse envelope.

The custom OpenAPI generator calls contract.enrich_openapi(...) to add:

Security schemes, error model, parameter definition, and named 200-response DTO.

Supports tags (grouping in Swagger) derived from the first path segment (e.g., /Allapps/... → tag “Allapps”).

Why this matters: The runtime enforces the same constraints as the spec. What Swagger shows is actually what the API enforces.

3) The registry (how you define endpoints)

procs.registry.json is intentionally minimal. For each endpoint, you provide:

schema – SQL schema (e.g., dbo)

proc – stored procedure name

path – REST path (e.g., /Allapps/GetAppsbyUID)

method – GET or POST (GET → query params; POST → JSON body)

optional modelName – name for the 200 response model (used in components.schemas)

optional params – (only if you want to override requiredness or add descriptions; otherwise inferred from SQL)

optional tags/group – to group in Swagger


4) How requests and responses are validated

Requests (security-sensitive):

GET: query parameters are validated against type/format/regex/maxLength/required. Extra query params are ignored (OpenAPI doesn’t flag extra query keys), but required ones must pass your regex/length.

POST: the request body is a strict object (additionalProperties: false). Only documented keys are allowed; values must pass type/format/regex/maxLength/required.

Responses (flexible rows):

200 responses always return { "rows": [...] }.

rows.items lists known columns with types/regex/nullable and allows extra columns (additionalProperties: true) so DB schema changes don’t break clients.

The envelope ({ rows }) is strict (additionalProperties: false) so scanners see a predictable shape.

Errors:

400: parameter validation errors (e.g., missing or regex mismatch) in your ErrorResponse envelope with specific errorcodes.

401: missing/invalid X-API-Key.

403: (reserved; currently not used by default but present in the spec).

404: route not found.

415: wrong media type for POST.

500: unhandled errors (DB connectivity, timeouts, etc.) in your ErrorResponse envelope.

5) OpenAPI + 42Crunch alignment

Your OpenAPI has:

components.securitySchemes.apiKeyAuth + global security → every op requires the header.

ErrorResponse component (exact shape you provided) → used in 4xx/5xx responses.

Parameter constraints (type/format/regex/maxLength) → avoids “unbounded string” warnings.

Strict POST body (additionalProperties: false) → avoids “request allows extra props” warnings.

Named 200 DTO per endpoint → consumers see the contract immediately; 42C can reason about it.

This is precisely what 42Crunch wants for a strong audit.

6) MCP: what it is and why you added it

Model Context Protocol (MCP) gives an AI agent a standard way to discover and call your functionality as tools with JSON Schemas (argument contracts). It does not replace REST; it’s a parallel interface specifically for agents.

Your MCP server reads the same registry and exposes one tool per endpoint.

Each tool advertises an input schema that matches your parameter rules (type, format, regex, maxLength, required).

When a tool is invoked, the server runs the same validation and the same DB proc as the REST API, and returns { rows: [...] }.

This dramatically reduces hallucination and mis-typed calls by agents; they follow the schema.

When to use MCP: In IDEs, agent frameworks, or any environment where the model should programmatically discover capabilities and call them safely.

7) Why not FastMCP (and why the plain MCP server is fine)

FastMCP is great when your tools are defined statically in Python with type hints (it auto-generates schemas).

Your tools are dynamic—driven by SQL metadata + a registry file—so the reference mcp server is more natural: you’re already generating JSON Schemas dynamically. Using FastMCP would either force generating Pydantic models on the fly (extra work) or still pass dict schemas (no real gain).

If later you want the DX benefits of FastMCP, you can swap in its decorators. The rest of your architecture doesn’t change.

8) Common operational notes & gotchas

Column names like col_123: You’ll only see those if SQL truly returns a NULL name in the DMV. The code keeps real names verbatim and only synthesizes when needed.

\u003C\u003E in regexes: Those were JSON-escaped </>; the code now excludes < and > from the whitelist to keep patterns readable.

Large column counts: If the DMV reports 400+ columns, the spec will faithfully include them. That’s correct and expected for some wide procs or dynamic SQL; you’re not “grabbing the whole database,” you’re documenting the first result set of that one proc.

Performance: DMV calls happen at startup (OpenAPI build time), not per request. Per-request we only validate parameters and execute the proc.

Security: MCP typically runs locally with env-based secrets; if you need remote or multi-tenant, consider hosting the MCP server per user/session.

9) How to add new endpoints (quick recipe)

Add an object to procs.registry.json with:

schema, proc, path, method (GET or POST)

optional modelName (for the 200 DTO name)

optional params if you want to mark required: true/false or add descriptions

Restart the service(s).

Check:

/docs → route shows under the tag (grouped by first path segment).

/openapi.json → a components.schemas.<ModelName> DTO exists and 200 $refs it.

MCP client → tool appears in the tool list with argument schema.

That’s it. Future users only need to clone the repo, set .env, and modify the registry—no code changes.
