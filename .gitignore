SQLSERVER_DRIVER=ODBC Driver 18 for SQL Server
SQLSERVER_SERVER=tcp:myserver.database.windows.net,1433
SQLSERVER_DATABASE=mydb
SQLSERVER_UID=myuser
SQLSERVER_PWD=mypassword
SQLSERVER_ENCRYPT=yes
SQLSERVER_TRUSTCERT=no

API_TITLE=ProcBridge API
API_VERSION=1.0.0
POOL_SIZE=8
API_KEY=super-secret-key
REGISTRY_PATH=./procs.registry.json
LOG_LEVEL=INFO



{
  "project": "apps-service",
  "endpoints": [
    {
      "schema": "dbo",
      "proc": "spGetAppsByUser",
      "path": "/apps/latest",
      "method": "GET",
      "summary": "Get apps visible to a user (latest reportmonth)",
      "description": "Calls dbo.spGetAppsByUser(@UserId, @AppIds).",
      "params": [
        { "name": "UserId", "required": true },   // override: required
        { "name": "AppIds", "required": false }   // optional; auto type & constraints
      ]
    }
  ]
}





import os
import queue
import logging
from typing import Any, Dict, List, Optional

import pyodbc
from dotenv import load_dotenv

load_dotenv()
logger = logging.getLogger("db")

def build_conn_str() -> str:
    driver   = os.getenv("SQLSERVER_DRIVER", "ODBC Driver 18 for SQL Server")
    server   = os.getenv("SQLSERVER_SERVER")
    database = os.getenv("SQLSERVER_DATABASE")
    encrypt  = os.getenv("SQLSERVER_ENCRYPT", "yes")
    tsc      = os.getenv("SQLSERVER_TRUSTCERT", "no")
    if not (server and database):
        raise RuntimeError("Missing SQL Server env vars; check .env")
    return f"Driver={{{driver}}};Server={server};Database={database};Encrypt={encrypt};TrustServerCertificate={tsc};".format(driver=driver)

CONN_STR = build_conn_str()
UID = os.getenv("SQLSERVER_UID")
PWD = os.getenv("SQLSERVER_PWD")
POOL_SIZE = int(os.getenv("POOL_SIZE", "8"))

class ODBCConnectionPool:
    """Tiny synchronous pyodbc pool suitable for FastAPI workers."""
    def __init__(self, size: int):
        self._q: "queue.Queue[pyodbc.Connection]" = queue.Queue(maxsize=size)
        for _ in range(size):
            cnxn = pyodbc.connect(CONN_STR, user=UID, password=PWD, autocommit=True, timeout=30)
            self._q.put(cnxn)
    def get(self) -> pyodbc.Connection:
        return self._q.get()
    def put(self, cnxn: pyodbc.Connection):
        self._q.put(cnxn)

def get_proc_parameters(pool: ODBCConnectionPool, schema: str, proc: str) -> List[Dict[str, Any]]:
    """
    Return parameter metadata for a stored proc (input + output).
    Fields: ordinal, name, is_output, sql_type, max_length, precision, scale, has_default
    """
    cnxn = pool.get()
    try:
        cur = cnxn.cursor()
        cur.execute("""
            SELECT p.parameter_id AS ordinal,
                   REPLACE(p.name,'@','') AS name,
                   p.is_output,
                   t.name AS sql_type,
                   p.max_length, p.precision, p.scale,
                   p.has_default_value
            FROM sys.parameters p
            JOIN sys.types t ON p.user_type_id = t.user_type_id
            WHERE p.object_id = OBJECT_ID(?)
            ORDER BY p.parameter_id;
        """, (f"[{schema}].[{proc}]",))
        return [{
            "ordinal": r[0],
            "name": r[1],
            "is_output": bool(r[2]),
            "sql_type": r[3].lower(),
            "max_length": r[4],
            "precision": r[5],
            "scale": r[6],
            "has_default": bool(r[7]),
        } for r in cur.fetchall()]
    finally:
        pool.put(cnxn)

def _coerce(sql_type: str, value: Any) -> Any:
    """Best-effort coercion JSON â†’ SQL type; ODBC validates further."""
    if value is None:
        return None
    t = sql_type.lower()
    try:
        if t in ("int", "smallint", "tinyint", "bigint"):
            return int(value)
        if t in ("bit",):
            return str(value).strip().lower() in ("1", "true", "yes")
        if t in ("decimal", "numeric", "money", "smallmoney", "float", "real"):
            return float(value)
        # Let ODBC parse ISO-8601 strings for date/time/uniqueidentifier/etc.
        return str(value)
    except Exception:
        return value  # DB will complain; API wraps

def exec_proc(
    pool: ODBCConnectionPool,
    schema: str,
    proc: str,
    args: Dict[str, Any],
    required_overrides: Optional[Dict[str, bool]] = None,
) -> List[Dict[str, Any]]:
    """
    Execute a stored procedure with named-args dict (input params only).
    'required_overrides' lets API layer force required/optional per param.
    Returns rows from SELECT as list[dict]. Missing required param -> raises KeyError(name).
    """
    cnxn = pool.get()
    try:
        cur = cnxn.cursor()
        meta = get_proc_parameters(pool, schema, proc)
        in_params = [p for p in meta if not p["is_output"]]

        bound = []
        for p in sorted(in_params, key=lambda x: x["ordinal"]):
            name = p["name"]
            is_required = True
            if required_overrides is not None and name in required_overrides:
                is_required = required_overrides[name]
            else:
                is_required = not p["has_default"]

            if name not in args or args[name] is None:
                if is_required:
                    raise KeyError(name)
                val = None
            else:
                val = _coerce(p["sql_type"], args[name])
            bound.append(val)

        placeholders = ", ".join("?" for _ in bound)
        call = f"{{CALL [{schema}].[{proc}] ({placeholders})}}" if bound else f"{{CALL [{schema}].[{proc}]}}"
        cur.execute(call, tuple(bound))
        cols = [c[0] for c in cur.description] if cur.description else []
        rows = [dict(zip(cols, r)) for r in cur.fetchall()] if cur.description else []
        return rows
    finally:
        pool.put(cnxn)



import os
import re
import json
from typing import Any, Dict, List, Optional

from db import ODBCConnectionPool, get_proc_parameters

# ---------------- Registry ----------------

def load_registry(path: str) -> Dict[str, Any]:
    if not os.path.exists(path):
        raise FileNotFoundError(f"Registry not found: {path}")
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

# ---------------- Inference helpers ----------------

_SQL_TO_OA = {
    "int": "integer",
    "smallint": "integer",
    "tinyint": "integer",
    "bigint": "integer",
    "bit": "boolean",
    "decimal": "number",
    "numeric": "number",
    "money": "number",
    "smallmoney": "number",
    "float": "number",
    "real": "number",
}

def _is_string_type(sql: str) -> bool:
    return sql in ("varchar","nvarchar","char","nchar","text","ntext","uniqueidentifier","sysname")

def _infer_oa_type(sql_type: str) -> str:
    return _SQL_TO_OA.get(sql_type.lower(), "string")

def _infer_maxlen(sql_type: str, max_length: int) -> Optional[int]:
    """
    Infer string maxLength from SQL metadata:
      - NVARCHAR: max_length is bytes; chars = max_length/2
      - VARCHAR/CHAR: max_length is chars directly
      - MAX types (-1): pick conservative default 4000
    """
    t = sql_type.lower()
    if not _is_string_type(t):
        return None
    if max_length is None:
        return None
    if max_length < 0:  # MAX
        return 4000
    if t in ("nvarchar","nchar"):
        return max_length // 2
    return max_length

def _infer_pattern(name: str, sql_type: str) -> Optional[str]:
    """
    Provide reasonable default regexes to please strict scanners without bloating the registry.
    Keep conservative and safe:
      - integer types: digits with optional leading '-'
      - boolean: '0|1|true|false' (case-insensitive validated at runtime, but OA is case-insensitive by convention)
      - likely CSV IDs param (name endswith 'ids' or contains 'list'): digits separated by commas
      - GUIDs: basic UUID v4 pattern
    """
    t = sql_type.lower()
    n = name.lower()
    if t in ("int","smallint","tinyint","bigint"):
        return r"^-?\d+$"
    if t == "bit":
        return r"^(?:0|1|true|false)$"
    if t in ("uniqueidentifier",):
        return r"^[0-9a-fA-F-]{36}$"
    if _is_string_type(t):
        if n.endswith("ids") or "id_list" in n or "ids_list" in n or "appids" in n:
            return r"^\s*\d+(?:\s*,\s*\d+)*\s*$"
    return None

# ---------------- Contract builder ----------------

def build_param_contract(
    pool: ODBCConnectionPool,
    schema: str,
    proc: str,
    method: str,
    registry_params: Optional[List[Dict[str, Any]]] = None,
) -> List[Dict[str, Any]]:
    """
    Return a list of param specs:
      [{ name, in, type, required, description?, pattern?, maxLength?, minLength?, enum? }, ...]
    Sources:
      - SQL metadata for discovery (names, sql types, lengths)
      - Registry for minimal overrides (required or custom type/pattern/length if provided)
    """
    meta = get_proc_parameters(pool, schema, proc)
    inputs = [m for m in meta if not m["is_output"]]
    # Map registry overrides (by name)
    reg_by_name = {p["name"]: p for p in (registry_params or []) if p.get("name")}

    specs: List[Dict[str, Any]] = []
    for m in inputs:
        name = m["name"]
        sql = m["sql_type"]
        maxlen = _infer_maxlen(sql, m.get("max_length", None))
        oa_type = _infer_oa_type(sql)
        pattern = _infer_pattern(name, sql)

        # default requiredness from DB; registry can override
        required = not m["has_default"]
        if name in reg_by_name and "required" in reg_by_name[name]:
            required = bool(reg_by_name[name]["required"])

        # source: GET=>query, POST=>body; registry can override "in"
        param_in = "query" if method.upper() == "GET" else "body"
        if name in reg_by_name and reg_by_name[name].get("in") in ("query","body"):
            param_in = reg_by_name[name]["in"]

        # allow user to specify type/pattern/maxLength explicitly if desired
        if name in reg_by_name and "type" in reg_by_name[name]:
            oa_type = reg_by_name[name]["type"]
        if name in reg_by_name and "pattern" in reg_by_name[name]:
            pattern = reg_by_name[name]["pattern"]
        if name in reg_by_name and "maxLength" in reg_by_name[name]:
            maxlen = reg_by_name[name]["maxLength"]

        spec: Dict[str, Any] = {
            "name": name,
            "in": param_in,
            "type": oa_type,
            "required": required,
            "description": reg_by_name.get(name, {}).get("description", sql.upper()),
        }
        if pattern:
            spec["pattern"] = pattern
        if isinstance(maxlen, int) and oa_type == "string":
            # put a reasonable upper bound; scanners like to see limits
            spec["maxLength"] = maxlen
        # pass-through extras from registry if present
        for k in ("minLength","enum","example","format"):
            if name in reg_by_name and k in reg_by_name[name]:
                spec[k] = reg_by_name[name][k]

        specs.append(spec)

    # If registry lists a param not found in SQL, include it (dev knows what theyâ€™re doing)
    for name, r in reg_by_name.items():
        if name not in {m["name"] for m in inputs}:
            param_in = r.get("in") or ("query" if method.upper() == "GET" else "body")
            spec = {
                "name": name,
                "in": param_in,
                "type": r.get("type", "string"),
                "required": bool(r.get("required", False)),
                "description": r.get("description",""),
            }
            for k in ("pattern","maxLength","minLength","enum","example","format"):
                if k in r: spec[k] = r[k]
            specs.append(spec)

    return specs

def required_overrides_from_specs(specs: List[Dict[str, Any]]) -> Dict[str, bool]:
    return {s["name"]: bool(s.get("required", False)) for s in specs}

# ---------------- Runtime validation ----------------

def validate_params(specs: List[Dict[str, Any]], carrier: Dict[str, Any], source: str) -> List[str]:
    """
    Validate param values in 'carrier' (query dict or body dict) according to specs with matching 'in' (query/body).
    Returns list of error codes.
    """
    errors: List[str] = []
    for s in specs:
        if s["in"] != source:
            continue
        name = s["name"]
        required = bool(s.get("required", False))
        val = carrier.get(name)
        if val is None:
            if required:
                errors.append(f"E_MISSING_{name.upper()}")
            continue

        # stringify for checks (OpenAPI recognizes types; at runtime weâ€™re conservative)
        v = str(val)
        # length checks
        if "maxLength" in s:
            try:
                if len(v) > int(s["maxLength"]):
                    errors.append(f"E_PARAM_MAXLEN_{name.upper()}")
            except Exception:
                errors.append(f"E_PARAM_MAXLEN_{name.upper()}")
        if "minLength" in s:
            try:
                if len(v) < int(s["minLength"]):
                    errors.append(f"E_PARAM_MINLEN_{name.upper()}")
            except Exception:
                errors.append(f"E_PARAM_MINLEN_{name.upper()}")

        # regex pattern
        if "pattern" in s and s["pattern"]:
            try:
                if not re.fullmatch(s["pattern"], v):
                    errors.append(f"E_PARAM_PATTERN_{name.upper()}")
            except re.error:
                errors.append(f"E_PARAM_PATTERN_{name.upper()}")

        # enum
        if "enum" in s and isinstance(s["enum"], list):
            if v not in [str(x) for x in s["enum"]]:
                errors.append(f"E_PARAM_ENUM_{name.upper()}")

    return errors

# ---------------- OpenAPI enrichment ----------------

def enrich_openapi(spec: Dict[str, Any], endpoints: List[Dict[str, Any]], pool: ODBCConnectionPool) -> Dict[str, Any]:
    """
    Update OpenAPI spec to add:
      - Global security scheme (apiKey)
      - 42C ErrorResponse schema
      - For GET: query parameters (with required/constraints) derived from auto-contract
      - For POST: strict requestBody (additionalProperties: false)
      - Generic 200 response (rows array) unless 'response' provided in registry
    """
    spec["openapi"] = "3.1.0"
    comps = spec.setdefault("components", {}).setdefault("schemas", {})
    comps["ErrorResponse"] = {
        "type":"object","additionalProperties":False,
        "properties":{
            "fault":{
                "type":"object","additionalProperties":False,
                "properties":{
                    "faultstring":{"type":"string"},
                    "detail":{
                        "oneOf":[
                            {"type":"object","properties":{"errorcode":{"type":"string"}},"additionalProperties":False},
                            {"type":"array","maxItems":10,"items":{"type":"object","properties":{"errorcode":{"type":"string"}},"additionalProperties":False}}
                        ]
                    }
                }
            }
        }
    }
    spec["components"].setdefault("securitySchemes", {})
    spec["components"]["securitySchemes"]["apiKeyAuth"] = {"type":"apiKey","in":"header","name":"X-API-Key"}
    spec["security"] = [{"apiKeyAuth": []}]

    paths = spec.get("paths", {})
    for ep in endpoints:
        schema, proc, path, method = ep["schema"], ep["proc"], ep["path"], ep["method"].upper()
        reg_params = ep.get("params", None)
        specs = build_param_contract(pool, schema, proc, method, reg_params)
        response_model = ep.get("response")

        if method == "GET":
            try:
                getop = paths[path]["get"]
            except KeyError:
                continue
            params = []
            for s in specs:
                if s["in"] != "query":
                    continue
                sch: Dict[str, Any] = {"type": s["type"]}
                for k in ("maxLength","minLength","pattern","format","enum","example"):
                    if k in s: sch[k] = s[k]
                params.append({
                    "name": s["name"],
                    "in": "query",
                    "required": bool(s.get("required", False)),
                    "schema": sch,
                    "description": s.get("description","")
                })
            getop["parameters"] = params
            # Error responses
            for sc in ("400","401","500"):
                getop.setdefault("responses", {}).setdefault(
                    sc,
                    {"description":"", "content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorResponse"}}}},
                )
            # 200 response
            if response_model and isinstance(response_model, dict):
                getop.setdefault("responses", {}).setdefault(
                    "200", {"description":"OK","content":{"application/json":{"schema": response_model}}}
                )
            else:
                getop.setdefault("responses", {}).setdefault(
                    "200", {"description":"OK","content":{"application/json":{"schema":{
                        "type":"object","additionalProperties":False,
                        "properties":{"rows":{"type":"array","items":{"type":"object","additionalProperties":True}}}
                    }}}}
                )

        elif method == "POST":
            try:
                postop = paths[path]["post"]
            except KeyError:
                continue
            # requestBody â€“ only body params
            props: Dict[str, Any] = {}
            required_props: List[str] = []
            for s in specs:
                if s["in"] != "body":
                    continue
                sch: Dict[str, Any] = {"type": s["type"]}
                for k in ("maxLength","minLength","pattern","format","enum","example"):
                    if k in s: sch[k] = s[k]
                props[s["name"]] = sch
                if s.get("required", False):
                    required_props.append(s["name"])
            postop["requestBody"] = {
                "required": True,
                "content": {"application/json": {"schema":{
                    "type":"object","properties":props,"required":required_props,"additionalProperties":False
                }}}
            }
            for sc in ("400","401","500"):
                postop.setdefault("responses", {}).setdefault(
                    sc,
                    {"description":"", "content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorResponse"}}}},
                )
            if response_model and isinstance(response_model, dict):
                postop.setdefault("responses", {}).setdefault(
                    "200", {"description":"OK","content":{"application/json":{"schema": response_model}}}
                )
            else:
                postop.setdefault("responses", {}).setdefault(
                    "200", {"description":"OK","content":{"application/json":{"schema":{
                        "type":"object","additionalProperties":False,
                        "properties":{"rows":{"type":"array","items":{"type":"object","additionalProperties":True}}}
                    }}}}
                )
    return spec





import os
import logging
from typing import Any, Dict, List, Optional
from contextlib import asynccontextmanager

from dotenv import load_dotenv
from fastapi import FastAPI, APIRouter, Request, Depends, Body, HTTPException
from fastapi.responses import JSONResponse
from fastapi.openapi.utils import get_openapi

from db import ODBCConnectionPool, exec_proc, POOL_SIZE
from contract import load_registry, build_param_contract, required_overrides_from_specs, validate_params, enrich_openapi

# ------------------------------------------------------------------------------
# Setup
# ------------------------------------------------------------------------------
load_dotenv()
logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger("api")

API_KEY = os.getenv("API_KEY", "super-secret-key")
REGISTRY_PATH = os.getenv("REGISTRY_PATH", "./procs.registry.json")

def require_api_key(request: Request):
    if request.headers.get("X-API-Key") != API_KEY:
        raise HTTPException(
            status_code=401,
            detail={"fault": {"faultstring": "Unauthorized", "detail": {"errorcode": "E_UNAUTHORIZED"}}},
        )

def error_response(status_code: int, faultstring: str, codes: str | List[str]) -> JSONResponse:
    detail = [{"errorcode": c} for c in codes] if isinstance(codes, list) else {"errorcode": codes}
    return JSONResponse(status_code=status_code, content={"fault": {"faultstring": faultstring, "detail": detail}})

# ------------------------------------------------------------------------------
# Lifespan (no deprecated on_event)
# ------------------------------------------------------------------------------
@asynccontextmanager
async def lifespan(app: FastAPI):
    app.state.pool = ODBCConnectionPool(size=POOL_SIZE)
    app.state.registry = load_registry(REGISTRY_PATH)
    register_from_registry(app)
    yield

app = FastAPI(
    title=os.getenv("API_TITLE", "ProcBridge API"),
    version=os.getenv("API_VERSION", "1.0.0"),
    description="Expose selected stored procedures as APIs. Contracts auto-generated from SQL metadata with tiny overrides.",
    lifespan=lifespan,
)

router = APIRouter()

# ------------------------------------------------------------------------------
# Dynamic routes
# ------------------------------------------------------------------------------
def register_from_registry(app: FastAPI):
    for ep in app.state.registry.get("endpoints", []):
        register_endpoint(app, ep)
    app.include_router(router)

def register_endpoint(app: FastAPI, ep: Dict[str, Any]):
    schema = ep["schema"]; proc = ep["proc"]; path = ep["path"]; method = ep["method"].upper()
    summary = ep.get("summary", f"Execute {schema}.{proc}")
    description = ep.get("description", "")

    async def handle_get(request: Request, _auth=Depends(require_api_key)):
        try:
            pool: ODBCConnectionPool = request.app.state.pool
            specs = build_param_contract(pool, schema, proc, "GET", ep.get("params"))
            # pull & validate query
            query = dict(request.query_params)
            errcodes = validate_params(specs, query, source="query")
            if errcodes:
                return error_response(400, "Bad Request", errcodes[:10])
            # build args dict only from declared query params
            args = {s["name"]: query.get(s["name"]) for s in specs if s["in"] == "query" and s["name"] in query}
            rows = exec_proc(pool, schema, proc, args, required_overrides=required_overrides_from_specs(specs))
            return {"rows": rows}
        except KeyError as k:
            return error_response(400, "Bad Request", f"E_MISSING_{str(k).strip('\"').upper()}")
        except Exception:
            logger.exception("GET exec failed for %s.%s", schema, proc)
            return error_response(500, "Server error", "E_SERVER")

    async def handle_post(payload: Dict[str, Any] = Body(...), request: Request = None, _auth=Depends(require_api_key)):
        try:
            if not isinstance(payload, dict):
                return error_response(400, "Bad Request", "E_BODY_NOT_OBJECT")
            pool: ODBCConnectionPool = request.app.state.pool
            specs = build_param_contract(pool, schema, proc, "POST", ep.get("params"))
            errcodes = validate_params(specs, payload, source="body")
            if errcodes:
                return error_response(400, "Bad Request", errcodes[:10])
            rows = exec_proc(pool, schema, proc, payload, required_overrides=required_overrides_from_specs(specs))
            return {"rows": rows}
        except KeyError as k:
            return error_response(400, "Bad Request", f"E_MISSING_{str(k).strip('\"').upper()}")
        except Exception:
            logger.exception("POST exec failed for %s.%s", schema, proc)
            return error_response(500, "Server error", "E_SERVER")

    if method == "GET":
        router.add_api_route(
            path, handle_get, methods=["GET"], name=f"{schema}.{proc}",
            summary=summary, description=description,
            responses={200: {"description":"OK"}, 400: {"description":"Bad Request"}, 401: {"description":"Unauthorized"}, 500: {"description":"Server Error"}},
        )
    elif method == "POST":
        router.add_api_route(
            path, handle_post, methods=["POST"], name=f"{schema}.{proc}",
            summary=summary, description=description,
            responses={200: {"description":"OK"}, 400: {"description":"Bad Request"}, 401: {"description":"Unauthorized"}, 500: {"description":"Server Error"}},
        )
    else:
        raise RuntimeError(f"Unsupported method '{method}'. Use GET or POST.")

# ------------------------------------------------------------------------------
# OpenAPI 3.1 with 42C error schema + auto params/requestBody + security
# ------------------------------------------------------------------------------
def custom_openapi():
    spec = get_openapi(
        title=app.title, version=app.version, description=app.description, routes=app.routes
    )
    # let contract builder enrich the spec based on SQL metadata + tiny overrides
    return enrich_openapi(spec, app.state.registry.get("endpoints", []), app.state.pool)

app.openapi = custom_openapi

# ------------------------------------------------------------------------------
# Local run helper
# ------------------------------------------------------------------------------
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=False)





def enrich_openapi(spec: Dict[str, Any], endpoints: List[Dict[str, Any]], pool: ODBCConnectionPool) -> Dict[str, Any]:
    spec["openapi"] = "3.1.0"

    # servers (optional but useful for scans)
    spec.setdefault("servers", [{"url": "/"}])

    comps = spec.setdefault("components", {}).setdefault("schemas", {})
    comps["ErrorResponse"] = {
        "type":"object","additionalProperties":False,
        "properties":{
            "fault":{
                "type":"object","additionalProperties":False,
                "properties":{
                    "faultstring":{"type":"string"},
                    "detail":{
                        "oneOf":[
                            {"type":"object","properties":{"errorcode":{"type":"string"}},"additionalProperties":False},
                            {"type":"array","maxItems":10,"items":{"type":"object","properties":{"errorcode":{"type":"string"}},"additionalProperties":False}}
                        ]
                    }
                }
            }
        }
    }

    # Security
    spec["components"].setdefault("securitySchemes", {})
    spec["components"]["securitySchemes"]["apiKeyAuth"] = {"type":"apiKey","in":"header","name":"X-API-Key"}
    spec["security"] = [{"apiKeyAuth": []}]

    def attach_common_errors(op: Dict[str, Any], method: str):
        # Always include 400 (client input), 401/403 (since security is applied), 404 (not found), 415 (bad media for POST), 500
        errors = ["400", "401", "403", "404", "500"]
        if method == "POST":
            errors.append("415")
        for sc in errors:
            op.setdefault("responses", {}).setdefault(
                sc,
                {"description":"", "content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorResponse"}}}},
            )

    for ep in endpoints:
        schema, proc, path, method = ep["schema"], ep["proc"], ep["path"], ep["method"].upper()
        reg_params = ep.get("params", None)
        specs_list = build_param_contract(pool, schema, proc, method, reg_params)
        response_model = ep.get("response")

        if method == "GET":
            try:
                getop = spec["paths"][path]["get"]
            except KeyError:
                continue
            # Query parameters from auto-contract
            params = []
            for s in specs_list:
                if s["in"] != "query": 
                    continue
                sch: Dict[str, Any] = {"type": s["type"]}
                for k in ("maxLength","minLength","pattern","format","enum","example"):
                    if k in s: sch[k] = s[k]
                params.append({
                    "name": s["name"],
                    "in": "query",
                    "required": bool(s.get("required", False)),
                    "schema": sch,
                    "description": s.get("description","")
                })
            getop["parameters"] = params

            # 200 response
            if response_model and isinstance(response_model, dict):
                getop.setdefault("responses", {}).setdefault(
                    "200", {"description":"OK","content":{"application/json":{"schema": response_model}}}
                )
            else:
                # fallback: generic rows array (dev can tighten later in registry)
                getop.setdefault("responses", {}).setdefault(
                    "200", {"description":"OK","content":{"application/json":{"schema":{
                        "type":"object","additionalProperties":False,
                        "properties":{"rows":{"type":"array","items":{"type":"object","additionalProperties":True}}}
                    }}}}
                )

            attach_common_errors(getop, "GET")

        elif method == "POST":
            try:
                postop = spec["paths"][path]["post"]
            except KeyError:
                continue
            # requestBody from body params
            props: Dict[str, Any] = {}
            required_props: List[str] = []
            for s in specs_list:
                if s["in"] != "body": 
                    continue
                sch: Dict[str, Any] = {"type": s["type"]}
                for k in ("maxLength","minLength","pattern","format","enum","example"):
                    if k in s: sch[k] = s[k]
                props[s["name"]] = sch
                if s.get("required", False):
                    required_props.append(s["name"])
            postop["requestBody"] = {
                "required": True,
                "content": {"application/json": {"schema":{
                    "type":"object","properties":props,"required":required_props,"additionalProperties":False
                }}}
            }

            # 200 response
            if response_model and isinstance(response_model, dict):
                postop.setdefault("responses", {}).setdefault(
                    "200", {"description":"OK","content":{"application/json":{"schema": response_model}}}
                )
            else:
                postop.setdefault("responses", {}).setdefault(
                    "200", {"description":"OK","content":{"application/json":{"schema":{
                        "type":"object","additionalProperties":False,
                        "properties":{"rows":{"type":"array","items":{"type":"object","additionalProperties":True}}}
                    }}}}
                )

            attach_common_errors(postop, "POST")

    return spec





